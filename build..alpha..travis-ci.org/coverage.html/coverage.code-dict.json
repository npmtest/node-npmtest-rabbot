{"/home/travis/build/npmtest/node-npmtest-rabbot/test.js":"/* istanbul instrument in package npmtest_rabbot */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rabbot/lib.npmtest_rabbot.js":"/* istanbul instrument in package npmtest_rabbot */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_rabbot = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_rabbot = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-rabbot/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-rabbot && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_rabbot */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_rabbot\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_rabbot.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_rabbot.rollup.js'] =\n            local.assetsDict['/assets.npmtest_rabbot.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_rabbot.__dirname + '/lib.npmtest_rabbot.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/index.js":"var _ = require( \"lodash\" );\nvar Monologue = require( \"monologue.js\" );\nvar when = require( \"when\" );\nvar connectionFn = require( \"./connectionFsm.js\" );\nvar topologyFn = require( \"./topology.js\" );\nvar postal = require( \"postal\" );\nvar uuid = require( \"uuid\" );\nvar dispatch = postal.channel( \"rabbit.dispatch\" );\nvar responses = postal.channel( \"rabbit.responses\" );\nvar signal = postal.channel( \"rabbit.ack\" );\nvar format = require( \"util\" ).format;\n\nvar unhandledStrategies = {\n\tnackOnUnhandled: function( message ) {\n\t\tmessage.nack();\n\t},\n\trejectOnUnhandled: function( message ) {\n\t\tmessage.reject();\n\t},\n\tcustomOnUnhandled: function() {}\n};\nvar returnedStrategies = {\n\tcustomOnReturned: function() {}\n};\nunhandledStrategies.onUnhandled = unhandledStrategies.nackOnUnhandled;\nreturnedStrategies.onReturned = returnedStrategies.customOnReturned;\n\nvar serializers = {\n\t\"application/json\": {\n\t\tdeserialize: function( bytes, encoding ) {\n\t\t\treturn JSON.parse( bytes.toString( encoding || \"utf8\" ) );\n\t\t},\n\t\tserialize: function( object ) {\n\t\t\treturn new Buffer( JSON.stringify( object ), \"utf8\" );\n\t\t}\n\t},\n\t\"application/octet-stream\": {\n\t\tdeserialize: function( bytes ) {\n      return bytes;\n\t\t},\n\t\tserialize: function( bytes ) {\n      if( Buffer.isBuffer( bytes ) ) {\n        return bytes;\n      } else if( _.isArray( bytes ) ) {\n        return Buffer.from( bytes );\n      } else {\n        throw new Error( \"Cannot serialize unknown data type\" );\n      }\n\t\t}\n\t},\n\t\"text/plain\": {\n\t\tdeserialize: function( bytes, encoding ) {\n\t\t\treturn bytes.toString( encoding || \"utf8\" );\n\t\t},\n\t\tserialize: function( string ) {\n\t\t\treturn new Buffer( string, \"utf8\" );\n\t\t}\n\t}\n};\n\nvar Broker = function() {\n\tthis.connections = {};\n\tthis.hasHandles = false;\n\tthis.autoNack = false;\n\tthis.serializers = serializers;\n\tthis.configurations = {};\n\t_.bindAll( this );\n};\n\nBroker.prototype.addConnection = function( options ) {\n\tvar self = this\n\n\tvar connectionPromise;\n\tvar name = options ? ( options.name || \"default\" ) : \"default\";\n\toptions = options || {};\n\toptions.name = name;\n\toptions.retryLimit = options.retryLimit || 3;\n\toptions.failAfter = options.failAfter || 60;\n\tvar connection;\n\n\tconnectionPromise = when.promise( function( resolve, reject ) {\n\t\tif ( !self.connections[ name ] ) {\n\t\t\tconnection = connectionFn( options );\n\t\t\tvar topology = topologyFn( connection, options || {}, serializers, unhandledStrategies, returnedStrategies );\n\t\t\tconnection.on( \"connected\", function() {\n\t\t\t\tself.emit( \"connected\", connection );\n\t\t\t\tself.emit( connection.name + \".connection.opened\", connection );\n\t\t\t\tself.setAckInterval( 500 );\n\t\t\t\treturn resolve( topology )\n\t\t\t} );\n\t\t\tconnection.on( \"closed\", function() {\n\t\t\t\tself.emit( \"closed\", connection );\n\t\t\t\tself.emit( connection.name + \".connection.closed\", connection );\n\t\t\t\treturn reject( new Error( \"connection closed\" ) )\n\t\t\t} );\n\t\t\tconnection.on( \"failed\", function( err ) {\n\t\t\t\tself.emit( \"failed\", connection );\n\t\t\t\tself.emit( name + \".connection.failed\", err );\n\t\t\t\treturn reject( err )\n\t\t\t} );\n\t\t\tconnection.on( \"unreachable\", function() {\n\t\t\t\tself.emit( \"unreachable\", connection );\n\t\t\t\tself.emit( name + \".connection.unreachable\" );\n\t\t\t\tself.clearAckInterval();\n\t\t\t\treturn reject( new Error( \"connection unreachable\" ) )\n\t\t\t} );\n\t\t\tconnection.on( \"return\", function(raw) {\n\t\t\t\tself.emit( \"return\", raw );\n\t\t\t} );\n\t\t\tself.connections[ name ] = topology;\n\t\t} else {\n\t\t\tconnection = self.connections[ name ];\n\t\t\tconnection.connection.connect();\n\t\t\tresolve( connection );\n\t\t}\n\t} );\n\tif( !this.connections[ name ].promise ) {\n\t\tthis.connections[ name ].promise = connectionPromise;\n\t}\n\treturn connectionPromise;\n};\n\nBroker.prototype.addExchange = function( name, type, options, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n  if( !type && !options ) {\n    options = {};\n  }\n\tif ( _.isObject( name ) ) {\n\t\toptions = name;\n\t\tconnectionName = type;\n\t} else {\n\t\toptions.name = name;\n\t\toptions.type = type;\n\t}\n\treturn this.connections[ connectionName ].createExchange( options );\n};\n\nBroker.prototype.addQueue = function( name, options, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n  options = options || {};\n\toptions.name = name;\n\tif ( options.subscribe && !this.hasHandles ) {\n\t\tconsole.warn( \"Subscription to '\" + name + \"' was started without any handlers. This will result in lost messages!\" );\n\t}\n\treturn this.connections[ connectionName ].createQueue( options, connectionName );\n};\n\nBroker.prototype.addSerializer = function( contentType, serializer ) {\n\tserializers[ contentType ] = serializer;\n};\n\nBroker.prototype.batchAck = function() {\n\tsignal.publish( \"ack\", {} );\n};\n\nBroker.prototype.bindExchange = function( source, target, keys, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n\treturn this.connections[ connectionName ].createBinding( { source: source, target: target, keys: keys } );\n};\n\nBroker.prototype.bindQueue = function( source, target, keys, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n\treturn this.connections[ connectionName ].createBinding(\n\t\t{ source: source, target: target, keys: keys, queue: true },\n\t\tconnectionName\n\t);\n};\n\nBroker.prototype.clearAckInterval = function() {\n\tclearInterval( this.ackIntervalId );\n};\n\nBroker.prototype.closeAll = function( reset ) {\n\t// COFFEE IS FOR CLOSERS\n\tvar closers = _.map( this.connections, function( connection ) {\n\t\treturn this.close( connection.name, reset );\n\t}.bind( this ) );\n\treturn when.all( closers );\n};\n\nBroker.prototype.close = function( connectionName, reset ) {\n\tconnectionName = connectionName || \"default\";\n\tvar connection = this.connections[ connectionName ].connection;\n\tif ( !_.isUndefined( connection ) ) {\n\t\tif( reset ) {\n\t\t\tthis.connections[ connectionName ].reset();\n\t\t}\n\t\treturn connection.close( reset );\n\t} else {\n\t\treturn when( true );\n\t}\n};\n\nBroker.prototype.deleteExchange = function( name, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n\treturn this.connections[ connectionName ].deleteExchange( name );\n};\n\nBroker.prototype.deleteQueue = function( name, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n\treturn this.connections[ connectionName ].deleteQueue( name );\n};\n\nBroker.prototype.getExchange = function( name, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n\treturn this.connections[ connectionName ].channels[ \"exchange:\" + name ];\n};\n\nBroker.prototype.getQueue = function( name, connectionName ) {\n\tconnectionName = connectionName || \"default\";\n\treturn this.connections[ connectionName ].channels[ \"queue:\" + name ];\n};\n\nBroker.prototype.handle = function( messageType, handler, queueName, context ) {\n\tthis.hasHandles = true;\n\tvar options;\n\tif( _.isString( messageType ) ) {\n\t\toptions = {\n\t\t\ttype: messageType,\n\t\t\tqueue: queueName || \"*\",\n\t\t\tcontext: context,\n\t\t\tautoNack: this.autoNack,\n\t\t\thandler: handler\n\t\t}\n\t} else {\n\t\toptions = messageType;\n\t\toptions.autoNack = options.autoNack === false ? false : true;\n\t\toptions.queue = options.queue || (options.type ? '*' : '#');\n\t\toptions.handler = options.handler || handler;\n\t}\n\tvar parts = [];\n\tif( options.queue === \"#\" ) {\n\t\tparts.push( \"#\" );\n\t} else {\n\t\tparts.push( options.queue.replace( /[.]/g, \"-\" ) );\n\t\tif( options.type !== \"\" ) {\n\t\t\tparts.push( options.type || \"#\" );\n\t\t}\n\t}\n\n\tvar target = parts.join( \".\" );\n\tvar subscription = dispatch.subscribe( target, options.handler.bind( options.context ) );\n\tif ( options.autoNack ) {\n\t\tsubscription.catch( function( err, msg ) {\n\t\t\tconsole.log( \"Handler for '\" + target + \"' failed with:\", err.stack );\n\t\t\tmsg.nack();\n\t\t} );\n\t}\n\tsubscription.remove = subscription.unsubscribe;\n\treturn subscription;\n};\n\nBroker.prototype.ignoreHandlerErrors = function() {\n\tthis.autoNack = false;\n};\n\nBroker.prototype.nackOnError = function() {\n\tthis.autoNack = true;\n};\n\nBroker.prototype.nackUnhandled = function() {\n\tunhandledStrategies.onUnhandled = unhandledStrategies.nackOnUnhandled;\n};\n\nBroker.prototype.onUnhandled = function( handler ) {\n\tunhandledStrategies.onUnhandled = unhandledStrategies.customOnUnhandled = handler;\n};\n\nBroker.prototype.rejectUnhandled = function() {\n\tunhandledStrategies.onUnhandled = unhandledStrategies.rejectOnUnhandled;\n};\n\nBroker.prototype.onReturned = function( handler ) {\n\treturnedStrategies.onReturned = returnedStrategies.customOnReturned = handler;\n};\n\nBroker.prototype.publish = function( exchangeName, type, message, routingKey, correlationId, connectionName, sequenceNo ) {\n\tvar timestamp = Date.now();\n\tvar options;\n\tif ( _.isObject( type ) ) {\n\t\toptions = type;\n\t\tconnectionName = message || options.connectionName || \"default\";\n\t} else {\n\t\tconnectionName = connectionName || message.connectionName || \"default\";\n\t\toptions = {\n\t\t\tappId: this.appId,\n\t\t\ttype: type,\n\t\t\tbody: message,\n\t\t\troutingKey: routingKey,\n\t\t\tcorrelationId: correlationId,\n\t\t\tsequenceNo: sequenceNo,\n\t\t\ttimestamp: timestamp,\n\t\t\theaders: {},\n\t\t\tconnectionName: connectionName\n\t\t};\n\t}\n\tif( !this.connections[ connectionName ] ) {\n\t\treturn when.reject( new Error( format( \"Publish failed - no connection %s has been configured\", connectionName ) ) );\n\t}\n\tif( this.connections[ connectionName ] && this.connections[ connectionName ].options.publishTimeout ) {\n\t\toptions.connectionPublishTimeout = this.connections[ connectionName ].options.publishTimeout;\n\t}\n\tif( _.isNumber( options.body ) ) {\n\t\toptions.body = options.body.toString();\n\t}\n\n\treturn this.connections[ connectionName ].promise\n\t\t.then( function() {\n\t\t\tvar exchange = this.getExchange( exchangeName, connectionName );\n\t\t\tif( exchange ) {\n\t\t\t\treturn exchange.publish( options );\n\t\t\t} else {\n\t\t\t\treturn when.reject( new Error( format( \"Publish failed - no exchange %s on connection %s is defined\", exchangeName, connectionName ) ) );\n\t\t\t}\n\t\t}.bind( this ) );\n};\n\nBroker.prototype.request = function( exchangeName, options, notify, connectionName ) {\n  if( _.isFunction( notify ) ) {\n    connectionName = connectionName || options.connectionName || 'default';\n  } else {\n    connectionName = notify || options.connectionName || 'default';\n  }\n\tvar requestId = uuid.v1();\n\toptions.messageId = requestId;\n\toptions.connectionName = connectionName;\n\tvar connection = this.connections[ connectionName ].options;\n\tvar exchange = this.getExchange( exchangeName, connectionName );\n\tvar publishTimeout = options.timeout || exchange.publishTimeout || connection.publishTimeout || 500;\n\tvar replyTimeout = options.replyTimeout || exchange.replyTimeout || connection.replyTimeout || ( publishTimeout * 2 );\n\n\treturn when.promise( function( resolve, reject ) {\n\t\tvar timeout = setTimeout( function() {\n\t\t\tsubscription.unsubscribe();\n\t\t\treject( new Error( \"No reply received within the configured timeout of \" + replyTimeout + \" ms\" ) );\n\t\t}, replyTimeout );\n\t\tvar subscription = responses.subscribe( requestId, function( message ) {\n\t\t\tif ( message.properties.headers[ \"sequence_end\" ] ) { // jshint ignore:line\n\t\t\t\tclearTimeout( timeout );\n\t\t\t\tresolve( message );\n\t\t\t\tsubscription.unsubscribe();\n\t\t\t} else if( notify ) {\n\t\t\t\tnotify( message );\n\t\t\t}\n\t\t} );\n\t\tthis.publish( exchangeName, options );\n\n\t}.bind( this ) );\n};\n\nBroker.prototype.reset = function() {\n\tthis.connections = {};\n\tthis.configurations = {};\n};\n\nBroker.prototype.retry = function( connectionName ) {\n\tconnectionName = connectionName || \"default\";\n\tvar config = this.configurations[ connectionName ];\n\treturn this.configure( config );\n};\n\nBroker.prototype.setAckInterval = function( interval ) {\n\tif ( this.ackIntervalId ) {\n\t\tthis.clearAckInterval();\n\t}\n\tthis.ackIntervalId = setInterval( this.batchAck, interval );\n};\n\nBroker.prototype.shutdown = function() {\n\treturn this.closeAll( true )\n\t\t.then( function() {\n\t\t\tthis.clearAckInterval();\n\t\t}.bind( this ) );\n};\n\nBroker.prototype.startSubscription = function( queueName, exclusive, connectionName ) {\n\tif ( !this.hasHandles ) {\n\t\tconsole.warn( \"Subscription to '\" + queueName + \"' was started without any handlers. This will result in lost messages!\" );\n\t}\n\tif( _.isString( exclusive ) ) {\n\t\tconnectionName = exclusive;\n\t\texclusive = false;\n\t}\n\tvar queue = this.getQueue( queueName, connectionName );\n\tif ( queue ) {\n\t\treturn queue.subscribe( exclusive );\n\t} else {\n\t\tthrow new Error( \"No queue named '\" + queueName + \"' for connection '\" + connectionName + \"'. Subscription failed.\" );\n\t}\n};\n\nBroker.prototype.stopSubscription = function( queueName, connectionName ) {\n\tvar queue = this.getQueue( queueName, connectionName );\n\tif( queue ) {\n\t\tqueue.unsubscribe();\n\t\treturn queue;\n\t} else {\n\t\tthrow new Error( \"No queue named '\" + queueName + \"' for connection '\" + connectionName + \"'. Unsubscribe failed.\" );\n\t}\n}\n\nrequire( \"./config.js\" )( Broker );\n\nMonologue.mixInto( Broker );\n\nvar broker = new Broker();\n\nmodule.exports = broker;\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/connectionFsm.js":"var _ = require( \"lodash\" );\nvar Monologue = require( \"monologue.js\" );\nvar when = require( \"when\" );\nvar machina = require( \"machina\" );\nvar format = require( \"util\" ).format;\nvar log = require( \"./log.js\" )( \"rabbot.connection\" );\n\n/* events emitted:\n\t'closing' - close is initiated by user\n\t'closed' - initiated close has completed\n\t'connecting' - connection initiated\n\t'connected' - connection established\n\t'reconnected' - lost connection recovered\n\t'failed' - connection lost\n\t'unreachable' - no end points could be reached within threshold\n \t'return' - published message was returned by AMQP\n*/\n\n/* logs:\n    * `rabbot.connection`\n\t  * `debug`:\n\t  \t* on successful acquisition of a new channel\n\t  * `info`:\n\t  \t* user initiated close started\n\t  \t* user initiated close completed\n\t  * `warn`:\n\t  \t* attempt to acquire a channel during user initiated connection close\n\t  \t* attempt to acquire a channel on a user-closed connection\n\t  * `error`:\n\t  \t* on failed channel creation\n\t  \t* failed reconnection\n*/\n\nvar Connection = function( options, connectionFn, channelFn ) {\n\tchannelFn = channelFn || require( './amqp/channel' );\n\tconnectionFn = connectionFn || require( './amqp/connection' );\n\n\tvar connection;\n\tvar queues = [];\n\tvar exchanges = [];\n\tvar channels = {};\n\n\tvar Fsm = machina.Fsm.extend( {\n\t\tname: options.name || \"default\",\n\t\tinitialState: \"initializing\",\n\t\tconnected: false,\n\t\tconsecutiveFailures: 0,\n\t\tconnectTimeout: undefined,\n\t\tfailAfter: ( options.failAfter || 60 ) * 1000,\n\n\t\tinitialize: function() {\n\t\t\toptions.name = this.name;\n\t\t},\n\n\t\t_closer: function() {\n\t\t\tconnection.close();\n\t\t},\n\n\t\t_getChannel: function ( name, confirm, context ) {\n      var channel = channels[ name ];\n\t\t\tif ( !channel ) {\n\t\t\t\treturn when.promise( function( resolve ) {\n\t\t\t\t\tchannel = channelFn.create( connection, name, confirm );\n\t\t\t\t\tchannels[ name ] = channel;\n\t\t\t\t\tchannel.on( \"acquired\", function() {\n\t\t\t\t\t\tthis._onChannel.bind( this, name, context );\n\t\t\t\t\t\tresolve( channel );\n\t\t\t\t\t}.bind( this ) );\n\t\t\t\t\tchannel.on( \"return\", function(raw) {\n\t\t\t\t\t\tthis.emit( \"return\", raw);\n\t\t\t\t\t}.bind(this));\n\t\t\t\t}.bind( this ) );\n\t\t\t} else {\n\t\t\t\treturn when( channel );\n\t\t\t}\n\t\t},\n\n\t\t_onChannel: function( name, context, channel ) {\n\t\t\tlog.debug( \"Acquired channel '%s' on '%s' successfully for '%s'\", name, this.name, context );\n\t\t\treturn channel;\n\t\t},\n\n\t\t_onChannelFailure: function( name, context, error ) {\n\t\t\tlog.error( \"Failed to create channel '%s' on '%s' for '%s' with %s\", name, this.name, error );\n\t\t\treturn when.reject( error );\n\t\t},\n\n\t\t_reconnect: function() {\n\t\t\tvar reacquisitions = _.map( channels, function( channel ) {\n\t\t\t\treturn when.promise( function( resolve ) {\n\t\t\t\t\tchannel.once( \"acquired\", function() {\n\t\t\t\t\t\tresolve( channel );\n\t\t\t\t\t} );\n\t\t\t\t\tchannel.acquire();\n\t\t\t\t}.bind( this ) );\n\t\t\t}.bind( this ) );\n\n\t\t\tfunction reacquired() {\n\t\t\t\tthis.emit( \"reconnected\" );\n\t\t\t}\n\n\t\t\tfunction reacquireFailed( err ) {\n\t\t\t\tlog.error( \"Could not complete reconnection of '%s' due to %s\", err );\n\t\t\t\tthis.transition( \"failed\" );\n\t\t\t\tthis.handle( \"failed\", err );\n\t\t\t}\n\n\t\t\twhen.all( reacquisitions )\n\t\t\t\t.then(\n\t\t\t\t\treacquired.bind( this ),\n\t\t\t\t\treacquireFailed.bind( this )\n\t\t\t\t);\n\t\t},\n\n\t\t_replay: function( ev ) {\n\t\t\treturn function( x ) {\n\t\t\t\tthis.handle( ev, x );\n\t\t\t}.bind( this );\n\t\t},\n\n\t\taddQueue: function( queue ) {\n\t\t\tqueues.push( queue );\n\t\t},\n\n\t\taddExchange: function( exchange ) {\n\t\t\texchanges.push( exchange );\n\t\t},\n\n\t\tclearConnectionTimeout: function() {\n\t\t\tif( this.connectionTimeout ) {\n\t\t\t\tclearTimeout( this.connectionTimeout );\n\t\t\t\tthis.connectionTimeout = null;\n\t\t\t}\n\t\t},\n\n\t\tgetChannel: function( name, confirm, context ) {\n\t\t\tvar deferred = when.defer();\n\t\t\tthis.handle( \"channel\", {\n\t\t\t\tname: name,\n\t\t\t\tconfirm: confirm,\n\t\t\t\tcontext: context,\n\t\t\t\tdeferred: deferred\n\t\t\t} );\n\t\t\treturn deferred.promise;\n\t\t},\n\n\t\tclose: function( reset ) {\n\t\t\tlog.info( \"Close initiated on connection '%s'\", this.name );\n\t\t\tvar deferred = when.defer();\n\t\t\tthis.handle( \"close\", deferred );\n\t\t\treturn deferred.promise\n\t\t\t\t.then( function() {\n\t\t\t\t\tif( reset ) {\n\t\t\t\t\t\tqueues = [];\n\t\t\t\t\t\texchanges = [];\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t},\n\n\t\tconnect: function() {\n\t\t\tthis.consecutiveFailures = 0;\n\t\t\tvar deferred = when.defer();\n\t\t\tthis.handle( \"connect\", deferred );\n\t\t\treturn deferred.promise;\n\t\t},\n\n\t\tlastError: function() {\n\t\t\treturn connection.lastError;\n\t\t},\n\n\t\tsetConnectionTimeout: function() {\n\t\t\tif( !this.connectionTimeout ) {\n\t\t\t\tthis.connectionTimeout = setTimeout( function() {\n\t\t\t\t\tthis.transition( \"unreachable\" );\n\t\t\t\t}.bind( this ), this.failAfter );\n\t\t\t}\n\t\t},\n\n\t\tstates: {\n\t\t\tinitializing: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tconnection = connectionFn( options );\n\t\t\t\t\tthis.setConnectionTimeout();\n\t\t\t\t\tconnection.on( \"acquiring\", this._replay( \"acquiring\" ) );\n\t\t\t\t\tconnection.on( \"acquired\", this._replay( \"acquired\" ) );\n\t\t\t\t\tconnection.on( \"failed\", this._replay( \"failed\" ) );\n\t\t\t\t\tconnection.on( \"closed\", this._replay( \"closed\" ) );\n\t\t\t\t\tconnection.on( \"released\", this._replay( \"released\" ) );\n\t\t\t\t},\n\t\t\t\tacquiring: function() {\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t},\n\t\t\t\tacquired: function() {\n\t\t\t\t\tthis.transition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tchannel: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tclose: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t\tthis.transition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tconnect: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t},\n\t\t\t\tfailed: function() {\n\t\t\t\t\tthis.deferUntilTransition();\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tconnecting: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.setConnectionTimeout();\n\t\t\t\t\tconnection.acquire()\n\t\t\t\t\t\t.then( null, function() {} );\n\t\t\t\t\tthis.emit( \"connecting\" );\n\t\t\t\t},\n\t\t\t\tacquired: function() {\n\t\t\t\t\tthis.transition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tchannel: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tclose: function() {\n\t\t\t\t\tthis.deferUntilTransition();\n\t\t\t\t},\n\t\t\t\tconnect: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tfailed: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"failed\" );\n\t\t\t\t\tthis.transition( \"failed\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tconnected: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.clearConnectionTimeout();\n\t\t\t\t\tthis.uri = connection.item.uri;\n\t\t\t\t\tthis.consecutiveFailures = 0;\n\t\t\t\t\tif ( this.connected ) {\n\t\t\t\t\t\tthis._reconnect();\n\t\t\t\t\t}\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tthis.emit( \"connected\", connection );\n\t\t\t\t},\n\t\t\t\tacquired: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connecting\" );\n\t\t\t\t},\n\t\t\t\tchannel: function( request ) {\n\t\t\t\t\tthis._getChannel( request.name, request.confirm, request.context )\n\t\t\t\t\t\t.then(\n\t\t\t\t\t\t\trequest.deferred.resolve,\n\t\t\t\t\t\t\trequest.deferred.reject\n\t\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tclose: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"closed\" );\n\t\t\t\t\tthis.transition( \"closing\" );\n\t\t\t\t},\n\t\t\t\tconnect: function( deferred ) {\n\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\tthis.emit( \"already-connected\", connection );\n\t\t\t\t},\n\t\t\t\tfailed: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"failed\" );\n\t\t\t\t\tthis.transition( \"failed\" );\n\t\t\t\t},\n\t\t\t\tclosed: function() {\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tclosed: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.clearConnectionTimeout();\n\t\t\t\t\tlog.info( 'Close on connection \\'%s\\' resolved', this.name );\n\t\t\t\t\tthis.emit( 'closed', {} );\n\t\t\t\t},\n\t\t\t\tacquiring: function() {\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t},\n\t\t\t\tchannel: function() {\n\t\t\t\t\tlog.warn( \"Channel '%s' on '%s' was requested for '%s' which was closed by user. Request will be deferred until connection is re-established explicitly by user.\" );\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tclose: function( deferred ) {\n\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\tconnection.release();\n\t\t\t\t\tthis.emit( \"closed\" );\n\t\t\t\t},\n\t\t\t\tconnect: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t},\n\t\t\t\tfailed: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"failed\" );\n\t\t\t\t\tthis.transition( \"failed\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tclosing: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.emit( \"closing\" );\n\t\t\t\t\tvar closeList = queues.concat( exchanges );\n\t\t\t\t\tif ( closeList.length ) {\n\t\t\t\t\t\twhen.all( _.map( closeList, function( channel ) {\n\t\t\t\t\t\t\treturn channel.release();\n\t\t\t\t\t\t} ) ).then( function() {\n\t\t\t\t\t\t\tthis._closer();\n\t\t\t\t\t\t}.bind( this ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._closer();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tchannel: function( request ) {\n\t\t\t\t\tlog.warn( \"Channel '%s' on '%s' was requested for '%s' during user initiated close. Request will be rejected.\" );\n\t\t\t\t\trequest.deferred.reject( new Error(\n\t\t\t\t\t\tformat( \"Illegal request for channel '%s' during close of connection '%s' initiated by user\",\n\t\t\t\t\t\t\trequest.name,\n\t\t\t\t\t\t\tthis.name\n\t\t\t\t\t\t)\n\t\t\t\t\t) );\n\t\t\t\t},\n\t\t\t\tconnect: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"closed\" );\n\t\t\t\t},\n\t\t\t\tclose: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"closed\" );\n\t\t\t\t},\n\t\t\t\tclosed: function() {\n\t\t\t\t\tthis.transition( \"closed\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\tthis.transition( \"closed\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tfailed: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.setConnectionTimeout();\n\t\t\t\t\tthis.consecutiveFailures ++;\n\t\t\t\t\tvar tooManyFailures = this.consecutiveFailures >= options.retryLimit;\n\t\t\t\t\tif( tooManyFailures ) {\n\t\t\t\t\t\tthis.transition( \"unreachable\" );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfailed: function( err ) {\n\t\t\t\t\tthis.emit( \"failed\", err );\n\t\t\t\t},\n\t\t\t\tacquiring: function() {\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t},\n\t\t\t\tchannel: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t},\n\t\t\t\tclose: function( deferred ) {\n\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\tconnection.release();\n\t\t\t\t\tthis.emit( \"closed\" );\n\t\t\t\t},\n\t\t\t\tconnect: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"connected\" );\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunreachable: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.clearConnectionTimeout();\n\t\t\t\t\tconnection\n\t\t\t\t\t\t.release()\n\t\t\t\t\t\t.then( function() {\n\t\t\t\t\t\t\tthis.emit( \"unreachable\" );\n\t\t\t\t\t\t}.bind( this ) );\n\t\t\t\t},\n\t\t\t\tconnect: function() {\n\t\t\t\t\tthis.consecutiveFailures = 0;\n\t\t\t\t\tthis.transition( \"connecting\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\tMonologue.mixInto( Fsm );\n\treturn new Fsm();\n};\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/log.js":"var log = require( \"whistlepunk\" ).log;\nlog( {} );\nmodule.exports = log;\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/topology.js":"var when = require( \"when\" );\nvar _ = require( \"lodash\" );\nvar Monologue = require( \"monologue.js\" );\nvar log = require( \"./log\" )( \"rabbot.topology\" );\nvar info = require( \"./info\" );\nvar Exchange, Queue;\nvar replyId;\n\n/* log\n\t* `rabbot.topology`\n\t  * `info`\n\t    * creating a binding\n\t    * deleting an exchange\n\t    * deleting a queue\n\t    * reconnection established\n\t    * topology rebuilt (after reconnection)\n\t  * `error`\n\t    * failed to create reply queue\n*/\n\nfunction getKeys( keys ) {\n\tvar actualKeys = [ \"\" ];\n\tif ( keys && keys.length > 0 ) {\n\t\tactualKeys = _.isArray( keys ) ? keys : [ keys ];\n\t}\n\treturn actualKeys;\n}\n\nfunction toArray( x, list ) {\n\tif ( _.isArray( x ) ) {\n\t\treturn x;\n\t}\n\tif ( _.isObject( x ) && list ) {\n\t\treturn _.map( x, function( item ) {\n\t\t\treturn item;\n\t\t} );\n\t}\n\tif ( _.isUndefined( x ) || _.isEmpty( x ) ) {\n\t\treturn [];\n\t}\n\treturn [ x ];\n}\n\nvar Topology = function( connection, options, serializers, unhandledStrategies, returnedStrategies ) {\n\tvar autoReplyTo = { name: [ replyId, \"response\", \"queue\" ].join( '.' ), autoDelete: true, subscribe: true };\n\tvar rabbitReplyTo = { name: \"amq.rabbitmq.reply-to\", subscribe: true, noAck: true };\n\tvar userReplyTo = _.isObject( options.replyQueue ) ? options.replyQueue : { name: options.replyQueue, autoDelete: true, subscribe: true };\n\tthis.name = options.name;\n\tthis.connection = connection;\n\tthis.channels = {};\n\tthis.promises = {};\n\tthis.definitions = {\n\t\tbindings: {},\n\t\texchanges: {},\n\t\tqueues: {}\n\t};\n\tthis.options = options;\n\tthis.replyQueue = { name: false };\n\tthis.serializers = serializers;\n\tthis.onUnhandled = function( message ) {\n\t\treturn unhandledStrategies.onUnhandled( message );\n\t};\n\tthis.onReturned = function( message ) {\n\t\treturn returnedStrategies.onReturned( message );\n\t};\n\tvar replyQueueName = '';\n\n\tif ( _.has( options, \"replyQueue\" ) ) {\n\t\treplyQueueName = options.replyQueue.name || options.replyQueue;\n\t\tif ( replyQueueName === false ) {\n\t\t\tthis.replyQueue = { name: false };\n\t\t} else if ( replyQueueName ) {\n\t\t\tthis.replyQueue = userReplyTo;\n\t\t} else if ( replyQueueName === \"rabbitmq\" ) {\n\t\t\tthis.replyQueue = rabbitReplyTo;\n\t\t}\n\t} else {\n\t\tthis.replyQueue = autoReplyTo;\n\t}\n\n\tfunction onReplyQueueFailed( err ) {\n\t\tlog.error( \"Failed to create reply queue for connection name '\" + connection.name || \"default\" + \"' with \", err );\n\t}\n\n\tconnection.on( \"reconnected\", function() {\n\t\tthis.createReplyQueue().then( null, onReplyQueueFailed );\n\t\tthis.onReconnect();\n\t}.bind( this ) );\n\n\tconnection.on( \"return\", function(raw) {\n\t\traw.type = _.isEmpty( raw.properties.type ) ? raw.fields.routingKey : raw.properties.type;\n\t\tvar contentType = raw.properties.contentType || \"application/octet-stream\";\n\t\tvar serializer = this.serializers[ contentType ];\n\t\tif( !serializer ) {\n\t\t\tlog.error( \"Could not deserialize message id %s, connection '%s' - no serializer defined\",\n\t\t\t\traw.properties.messageId, this.connection.name );\n\t\t} else {\n\t\t\ttry {\n\t\t\t\traw.body = serializer.deserialize( raw.content, raw.properties.contentEncoding );\n\t\t\t} catch( err ) {\n\t\t\t}\n\t\t}\n\n\t\tthis.onReturned(raw);\n\t}.bind( this ) );\n\n  this.createDefaultExchange().then( null, _.noop );\n\t// delay creation to allow for subscribers to attach a handler\n\tprocess.nextTick( function() {\n\t\tthis.createReplyQueue().then( null, onReplyQueueFailed );\n\t}.bind( this ) );\n};\n\nTopology.prototype.configureBindings = function( bindingDef, list ) {\n\tif ( _.isUndefined( bindingDef ) ) {\n\t\treturn when( true );\n\t} else {\n\t\tvar actualDefinitions = toArray( bindingDef, list );\n\t\tvar bindings = _.map( actualDefinitions, function( def ) {\n\t\t\t\tvar q = this.definitions.queues[ def.queueAlias ? def.queueAlias : def.target ];\n\t\t\t\treturn this.createBinding(\n\t\t\t\t\t{\n\t\t\t\t\t\tsource: def.exchange || def.source,\n\t\t\t\t\t\ttarget: q ? q.uniqueName : def.target,\n\t\t\t\t\t\tkeys: def.keys,\n\t\t\t\t\t\tqueue: q !== undefined,\n\t\t\t\t\t\tqueueAlias: q ? q.name : undefined\n\t\t\t\t\t} );\n\t\t\t}.bind( this ) );\n\t\tif ( bindings.length === 0 ) {\n\t\t\treturn when( true );\n\t\t} else {\n\t\t\treturn when.all( bindings );\n\t\t}\n\t}\n};\n\nTopology.prototype.configureQueues = function( queueDef, list ) {\n\tif ( _.isUndefined( queueDef ) ) {\n\t\treturn when( true );\n\t} else {\n\t\tvar actualDefinitions = toArray( queueDef, list );\n\t\tvar queues = _.map( actualDefinitions, function( def ) {\n\t\t\treturn this.createQueue( def );\n\t\t}.bind( this ) );\n\t\treturn when.all( queues );\n\t}\n};\n\nTopology.prototype.configureExchanges = function( exchangeDef, list ) {\n\tif ( _.isUndefined( exchangeDef ) ) {\n\t\treturn when( true );\n\t} else {\n\t\tvar actualDefinitions = toArray( exchangeDef, list );\n\t\tvar exchanges = _.map( actualDefinitions, function( def ) {\n\t\t\treturn this.createExchange( def );\n\t\t}.bind( this ) );\n\t\treturn when.all( exchanges );\n\t}\n};\n\nTopology.prototype.createBinding = function( options ) {\n\tvar id = [ options.source, options.target ].join( \"->\" );\n\tvar keys = getKeys( options.keys );\n\tif ( keys[0] !== \"\" ) {\n\t\tid += \":\" + keys.join(':');\n\t}\n\tvar promise = this.promises[ id ];\n\tif( !promise ) {\n\t\tthis.definitions.bindings[ id ] = options;\n\t\tvar call = options.queue ? \"bindQueue\" : \"bindExchange\";\n\t\tvar source = options.source;\n\t\tvar target = options.target;\n\t\tif( options.queue ) {\n\t\t\tvar queue = this.definitions.queues[ options.target ];\n\t\t\tif( queue && queue.uniqueName ) {\n\t\t\t\ttarget = queue.uniqueName;\n\t\t\t}\n\t\t}\n\t\tthis.promises[ id ] = promise = this.connection.getChannel( \"control\", false, \"control channel for bindings\" )\n\t\t\t.then( function( channel ) {\n\t\t\t\tlog.info( \"Binding %s '%s' to '%s' on '%s' with keys: %s\",\n\t\t\t\t\t( options.queue ? \"queue\" : \"exchange\" ), target, source, this.connection.name, JSON.stringify( keys ) );\n\t\t\t\treturn when.all(\n\t\t\t\t\t_.map( keys, function( key ) {\n\t\t\t\t\t\treturn channel[ call ]( target, source, key );\n\t\t\t\t\t} ) );\n\t\t\t}.bind( this ) );\n\n\t}\n\treturn promise;\n};\n\nTopology.prototype.createPrimitive = function( Primitive, primitiveType, options ) {\n\tvar errorFn = function( err ) {\n\t\treturn new Error( \"Failed to create \" + primitiveType + \" '\" + options.name +\n\t\t\t\"' on connection '\" + this.connection.name +\n\t\t\t\"' with '\" + ( err ? ( err.stack || err ) : \"N/A\" ) + \"'\" );\n\t}.bind( this );\n\tvar definitions = primitiveType === \"exchange\" ? this.definitions.exchanges : this.definitions.queues;\n\tvar channelName = [ primitiveType, options.name ].join( \":\" );\n\tvar promise = this.promises[ channelName ];\n\tif( !promise ) {\n\t\tthis.promises[ channelName ] = promise = when.promise( function( resolve, reject ) {\n\t\t\tdefinitions[ options.name ] = options;\n\t\t\tvar primitive = this.channels[ channelName ] = new Primitive( options, this.connection, this, this.serializers );\n\t\t\tvar onConnectionFailed = function( connectionError ) {\n\t\t\t\treject( errorFn( connectionError ) );\n\t\t\t};\n\t\t\tif ( this.connection.state === \"failed\" ) {\n\t\t\t\tonConnectionFailed( this.connection.lastError() );\n\t\t\t} else {\n\t\t\t\tvar onFailed = this.connection.on( \"failed\", function( err ) {\n\t\t\t\t\tonConnectionFailed( err );\n\t\t\t\t} );\n\t\t\t\tprimitive.once( \"defined\", function() {\n\t\t\t\t\tonFailed.unsubscribe();\n\t\t\t\t\tresolve( primitive );\n\t\t\t\t} );\n\t\t\t}\n\t\t\tprimitive.once( \"failed\", function( err ) {\n\t\t\t\tdelete definitions[ options.name ];\n\t\t\t\tdelete this.channels[ channelName ];\n        delete this.promises[ channelName ];\n\t\t\t\treject( errorFn( err ) );\n\t\t\t}.bind( this ) );\n\t\t}.bind( this ) );\n\t}\n\treturn promise;\n};\n\nTopology.prototype.createDefaultExchange = function() {\n  return this.createExchange( { name: \"\", passive: true } );\n}\n\nTopology.prototype.createExchange = function( options ) {\n\treturn this.createPrimitive( Exchange, \"exchange\", options );\n};\n\nTopology.prototype.createQueue = function( options ) {\n\toptions.uniqueName = this.getUniqueName( options );\n\treturn this.createPrimitive( Queue, \"queue\", options );\n};\n\nTopology.prototype.createReplyQueue = function() {\n\tif ( this.replyQueue.name === undefined || this.replyQueue.name === false ) {\n\t\treturn when.resolve();\n\t}\n\tvar key = \"queue:\" + this.replyQueue.name;\n\tvar promise;\n\tif ( !this.channels[ key ] ) {\n\t\tpromise = this.createQueue( this.replyQueue );\n\t\tpromise.then( function( channel ) {\n\t\t\tthis.channels[ key ] = channel;\n\t\t\tthis.emit( \"replyQueue.ready\", this.replyQueue );\n\t\t}.bind( this ) );\n\t} else {\n\t\tpromise = when.resolve( this.channels[ key ] );\n\t\tthis.emit( \"replyQueue.ready\", this.replyQueue );\n\t}\n\treturn promise;\n};\n\nTopology.prototype.deleteExchange = function( name ) {\n\tvar key = \"exchange:\" + name;\n\tvar channel = this.channels[ key ];\n\tif ( channel ) {\n\t\tchannel.release();\n\t\tdelete this.channels[ key ];\n\t\tlog.info( \"Deleting %s exchange '%s' on connection '%s'\", channel.type, name, this.connection.name );\n\t}\n\treturn this.connection.getChannel( \"control\", false, \"control channel for bindings\"  )\n\t\t.then( function( channel ) {\n\t\t\treturn channel.deleteExchange( name );\n\t\t} );\n};\n\nTopology.prototype.deleteQueue = function( name ) {\n\tvar key = \"queue:\" + name;\n\tvar channel = this.channels[ key ];\n\tif ( channel ) {\n\t\tchannel.release();\n\t\tdelete this.channels[ key ];\n\t\tlog.info( \"Deleting queue '%s' on connection '%s'\", name, this.connection.name );\n\t}\n\treturn this.connection.getChannel( \"control\", false, \"control channel for bindings\"  )\n\t\t.then( function( channel ) {\n\t\t\treturn channel.deleteQueue( name );\n\t\t} );\n};\n\nTopology.prototype.getUniqueName = function( options ) {\n\tif( options.unique === \"id\" ) {\n\t\treturn [ info.id, options.name ].join( \"-\" );\n\t} else if( options.unique === \"hash\" ) {\n\t\treturn [ options.name, info.createHash() ].join( \"-\" );\n\t} else if( options.unique === \"consistent\" ) {\n\t\treturn [ options.name, info.createConsistentHash() ].join( \"-\" );\n\t} else {\n\t\treturn options.name;\n\t}\n};\n\nTopology.prototype.onReconnect = function() {\n\tlog.info( \"Reconnection to '%s' established - rebuilding topology\", this.connection.name );\n\tthis.promises = {};\n\tvar prerequisites = _.map( this.channels, function( channel ) {\n\t\treturn channel.check ? channel.check() : when( true );\n\t}.bind( this ) );\n\treturn when.all( prerequisites )\n\t\t.then( function() {\n\t\t\treturn this.configureBindings( this.definitions.bindings, true )\n\t\t\t\t.then( function() {\n\t\t\t\t\tlog.info( \"Topology rebuilt for connection '%s'\", this.connection.name );\n\t\t\t\t\tthis.emit( \"bindings-completed\", this.definitions );\n          this.emit( this.connection.name + \".connection.configured\", this.connection );\n\t\t\t\t}.bind( this ) );\n\t\t}.bind( this ) );\n};\n\nTopology.prototype.reset = function() {\n\tthis.channels = {};\n\tthis.definitions = {\n\t\tbindings: {},\n\t\texchanges: {},\n\t\tqueues: {},\n\t\tsubscriptions: {}\n\t};\n};\n\nTopology.prototype.renameQueue = function( newQueueName ) {\n  var queue = this.definitions.queues[ \"\" ];\n  var channel = this.channels [ \"queue:\" ];\n  this.definitions.queues[ newQueueName ] = queue;\n  this.channels[ [ \"queue\", newQueueName ].join( \":\" ) ] = channel;\n  delete this.definitions.queues[ \"\" ];\n  delete this.channels[ \"queue:\" ];\n}\n\nMonologue.mixInto( Topology );\n\nmodule.exports = function( connection, options, serializers, unhandledStrategies, returnedStrategies, exchangeFsm, queueFsm, defaultId ) {\n\t// allows us to optionally provide mocks and control the default queue name\n\tExchange = exchangeFsm || require( \"./exchangeFsm.js\" );\n\tQueue = queueFsm || require( \"./queueFsm.js\" );\n\treplyId = defaultId || info.id;\n\n\treturn new Topology( connection, options, serializers, unhandledStrategies, returnedStrategies );\n};\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/info.js":"var crypto = require( \"crypto\" );\nvar os = require( \"os\" );\nvar format = require( \"util\" ).format;\nvar self = require( \"../package.json\" );\n\nvar host = os.hostname();\nvar platform = os.platform();\nvar architecture = os.arch();\nvar title = process.title;\nvar pid = process.pid;\nvar consumerId = format( '%s.%s.%s', host, title, pid );\nvar consistentId = format( '%s.%s', host, title );\nvar toBE = os.endianness() === \"BE\";\n\nfunction createConsumerTag( queueName ) {\n\tif( queueName.indexOf( consumerId ) === 0 ) {\n\t\treturn queueName;\n\t} else {\n\t\treturn format( \"%s.%s\", consumerId, queueName );\n\t}\n}\n\nfunction hash( id ) {\n\tvar bytes = crypto.createHash( \"md4\" ).update( id ).digest();\n\tvar num = toBE ? bytes.readdInt16BE() : bytes.readInt16LE();\n\treturn num < 0 ? Math.abs( num ) + 0xffffffff : num;\n}\n\n// not great, but good enough for our purposes\nfunction createConsumerHash() {\n\treturn hash( consumerId );\n}\n\nfunction createConsistentHash() {\n\treturn hash( consistentId );\n}\n\nfunction getHostInfo() {\n\treturn format( \"%s (%s %s)\", host, platform, architecture );\n}\n\nfunction getProcessInfo() {\n\treturn format( \"%s (pid: %d)\", title, pid );\n}\n\nfunction getLibInfo() {\n\treturn format( \"rabbot - %s\", self.version );\n}\n\nmodule.exports = {\n\tid: consumerId,\n\thost: getHostInfo,\n\tlib: getLibInfo,\n\tprocess: getProcessInfo,\n\tcreateTag: createConsumerTag,\n\tcreateHash: createConsumerHash,\n\tcreateConsistentHash: createConsistentHash\n};","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/config.js":"var when = require( \"when\" );\nvar format = require( \"util\" ).format;\nvar log = require( \"./log\" )( \"rabbot.configuration\" );\n\n/* log\n\t* `rabbot.configuration`\n\t  * error\n\t    * configuration failed (in exchange, queue or bindings)\n*/\n\nvar logger;\nmodule.exports = function( Broker ) {\n\tBroker.prototype.configure = function( config ) {\n\t\tif( !logger && config.logging ) {\n\t\t\tlogger = require( \"./log\" )( config.logging || {} );\n\t\t}\n\t\tvar emit = this.emit.bind( this );\n\t\tthis.configurations[ config.name || \"default\" ] = config;\n\t\treturn when.promise( function( resolve, reject ) {\n\n\t\t\tfunction onExchangeError( connection, err ) {\n\t\t\t\tlog.error( \"Configuration of %s failed due to an error in one or more exchange settings: %s\", connection.name, err );\n\t\t\t\treject( err );\n\t\t\t}\n\n\t\t\tfunction onQueueError( connection, err ) {\n\t\t\t\tlog.error( \"Configuration of %s failed due to an error in one or more queue settings: %s\", connection.name, err.stack );\n\t\t\t\treject( err );\n\t\t\t}\n\n\t\t\tfunction onBindingError( connection, err ) {\n\t\t\t\tlog.error( \"Configuration of %s failed due to an error in one or more bindings: %s\", connection.name, err.stack );\n\t\t\t\treject( err );\n\t\t\t}\n\n\t\t\tfunction createExchanges( connection ) {\n\t\t\t\tconnection.configureExchanges( config.exchanges )\n\t\t\t\t\t.then(\n\t\t\t\t\t\tcreateQueues.bind( null, connection ),\n\t\t\t\t\t\tonExchangeError.bind( null, connection )\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction createQueues( connection ) {\n\t\t\t\tconnection.configureQueues( config.queues )\n\t\t\t\t\t.then(\n\t\t\t\t\t\tcreateBindings.bind( null, connection ),\n\t\t\t\t\t\tonQueueError.bind( null, connection )\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction createBindings( connection ) {\n\t\t\t\tconnection.configureBindings( config.bindings, connection.name )\n\t\t\t\t\t.then(\n\t\t\t\t\t\tfinish.bind( null, connection ),\n\t\t\t\t\t\tonBindingError.bind( null, connection )\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tfunction finish( connection ) {\n\t\t\t\temit( connection.name + \".connection.configured\", connection );\n\t\t\t\tresolve();\n\t\t\t}\n\n\t\t\tthis.addConnection( config.connection )\n\t\t\t\t.then(\n\t\t\t\t\tfunction( connection ) {\n\t\t\t\t\t\tcreateExchanges( connection );\n\t\t\t\t\t\treturn connection;\n\t\t\t\t\t},\n\t\t\t\t\treject\n\t\t\t\t);\n\t\t}.bind( this ) );\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/.eslintrc.js":"module.exports = {\n    \"env\": {\n        \"es6\": true,\n        \"node\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"rules\": {\n        \"accessor-pairs\": \"error\",\n        \"array-bracket-spacing\": [\n            \"error\",\n            \"always\"\n        ],\n        \"array-callback-return\": \"error\",\n        \"arrow-body-style\": \"error\",\n        \"arrow-parens\": [\n            \"error\",\n            \"always\"\n        ],\n        \"arrow-spacing\": [\n            \"error\",\n            {\n                \"after\": true,\n                \"before\": true\n            }\n        ],\n        \"block-scoped-var\": \"error\",\n        \"block-spacing\": \"error\",\n        \"brace-style\": \"off\",\n        \"callback-return\": \"off\",\n        \"camelcase\": [\n            \"error\",\n            {\n                \"properties\": \"never\"\n            }\n        ],\n        \"class-methods-use-this\": \"error\",\n        \"comma-dangle\": \"error\",\n        \"comma-spacing\": [\n            \"error\",\n            {\n                \"after\": true,\n                \"before\": false\n            }\n        ],\n        \"comma-style\": [\n            \"error\",\n            \"last\"\n        ],\n        \"complexity\": \"off\",\n        \"computed-property-spacing\": \"off\",\n        \"consistent-return\": \"off\",\n        \"consistent-this\": \"off\",\n        \"curly\": \"error\",\n        \"default-case\": \"error\",\n        \"dot-location\": [\n            \"error\",\n            \"property\"\n        ],\n        \"dot-notation\": \"off\",\n        \"eol-last\": \"off\",\n        \"eqeqeq\": \"error\",\n        \"func-call-spacing\": \"error\",\n        \"func-names\": [\n            \"error\",\n            \"never\"\n        ],\n        \"func-style\": \"off\",\n        \"generator-star-spacing\": \"error\",\n        \"global-require\": \"off\",\n        \"guard-for-in\": \"error\",\n        \"handle-callback-err\": \"off\",\n        \"id-blacklist\": \"error\",\n        \"id-length\": \"off\",\n        \"id-match\": \"error\",\n        \"indent\": \"off\",\n        \"init-declarations\": \"off\",\n        \"jsx-quotes\": \"error\",\n        \"key-spacing\": \"off\",\n        \"keyword-spacing\": \"off\",\n        \"linebreak-style\": [\n            \"error\",\n            \"unix\"\n        ],\n        \"lines-around-comment\": \"error\",\n        \"max-depth\": \"error\",\n        \"max-len\": \"off\",\n        \"max-lines\": \"off\",\n        \"max-nested-callbacks\": \"error\",\n        \"max-params\": \"off\",\n        \"max-statements\": \"off\",\n        \"max-statements-per-line\": \"error\",\n        \"multiline-ternary\": [\n            \"error\",\n            \"never\"\n        ],\n        \"new-cap\": \"error\",\n        \"new-parens\": \"error\",\n        \"newline-after-var\": \"off\",\n        \"newline-before-return\": \"off\",\n        \"newline-per-chained-call\": \"off\",\n        \"no-alert\": \"error\",\n        \"no-array-constructor\": \"error\",\n        \"no-bitwise\": \"error\",\n        \"no-caller\": \"error\",\n        \"no-catch-shadow\": \"error\",\n        \"no-confusing-arrow\": \"error\",\n        \"no-continue\": \"error\",\n        \"no-console\": \"warn\",\n        \"no-div-regex\": \"error\",\n        \"no-duplicate-imports\": \"error\",\n        \"no-else-return\": \"off\",\n        \"no-empty\": [\n            \"error\",\n            {\n                \"allowEmptyCatch\": true\n            }\n        ],\n        \"no-empty-function\": \"off\",\n        \"no-eq-null\": \"error\",\n        \"no-eval\": \"error\",\n        \"no-extend-native\": \"error\",\n        \"no-extra-bind\": \"off\",\n        \"no-extra-label\": \"error\",\n        \"no-extra-parens\": \"off\",\n        \"no-floating-decimal\": \"error\",\n        \"no-global-assign\": \"error\",\n        \"no-implicit-coercion\": \"error\",\n        \"no-implicit-globals\": \"error\",\n        \"no-implied-eval\": \"error\",\n        \"no-inline-comments\": \"off\",\n        \"no-inner-declarations\": [\n            \"error\",\n            \"functions\"\n        ],\n        \"no-invalid-this\": \"error\",\n        \"no-iterator\": \"error\",\n        \"no-label-var\": \"error\",\n        \"no-labels\": \"error\",\n        \"no-lone-blocks\": \"error\",\n        \"no-lonely-if\": \"error\",\n        \"no-loop-func\": \"error\",\n        \"no-magic-numbers\": \"off\",\n        \"no-mixed-operators\": \"error\",\n        \"no-mixed-requires\": \"error\",\n        \"no-multi-spaces\": \"off\",\n        \"no-multi-str\": \"error\",\n        \"no-multiple-empty-lines\": \"error\",\n        \"no-negated-condition\": \"off\",\n        \"no-nested-ternary\": \"error\",\n        \"no-new\": \"error\",\n        \"no-new-func\": \"error\",\n        \"no-new-object\": \"error\",\n        \"no-new-require\": \"error\",\n        \"no-new-wrappers\": \"error\",\n        \"no-octal-escape\": \"error\",\n        \"no-param-reassign\": \"off\",\n        \"no-path-concat\": \"error\",\n        \"no-plusplus\": \"off\",\n        \"no-process-env\": \"error\",\n        \"no-process-exit\": \"error\",\n        \"no-proto\": \"error\",\n        \"no-prototype-builtins\": \"error\",\n        \"no-restricted-globals\": \"error\",\n        \"no-restricted-imports\": \"error\",\n        \"no-restricted-modules\": \"error\",\n        \"no-restricted-syntax\": \"error\",\n        \"no-return-assign\": \"error\",\n        \"no-script-url\": \"error\",\n        \"no-self-compare\": \"error\",\n        \"no-sequences\": \"error\",\n        \"no-shadow\": \"off\",\n        \"no-shadow-restricted-names\": \"error\",\n        \"no-spaced-func\": \"error\",\n        \"no-sync\": \"off\",\n        \"no-tabs\": \"off\",\n        \"no-template-curly-in-string\": \"error\",\n        \"no-ternary\": \"off\",\n        \"no-throw-literal\": \"error\",\n        \"no-trailing-spaces\": \"off\",\n        \"no-undef-init\": \"error\",\n        \"no-undefined\": \"off\",\n        \"no-underscore-dangle\": \"off\",\n        \"no-unmodified-loop-condition\": \"error\",\n        \"no-unneeded-ternary\": \"off\",\n        \"no-unsafe-negation\": \"error\",\n        \"no-unused-expressions\": \"error\",\n        \"no-unused-vars\": \"off\",\n        \"no-use-before-define\": \"off\",\n        \"no-useless-call\": \"error\",\n        \"no-useless-computed-key\": \"error\",\n        \"no-useless-concat\": \"off\",\n        \"no-useless-constructor\": \"error\",\n        \"no-useless-escape\": \"error\",\n        \"no-useless-rename\": \"error\",\n        \"no-var\": \"off\",\n        \"no-void\": \"error\",\n        \"no-warning-comments\": \"error\",\n        \"no-whitespace-before-property\": \"error\",\n        \"no-with\": \"error\",\n        \"object-curly-newline\": \"off\",\n        \"object-curly-spacing\": [\n            \"error\",\n            \"always\"\n        ],\n        \"object-property-newline\": [\n            \"error\",\n            {\n                \"allowMultiplePropertiesPerLine\": true\n            }\n        ],\n        \"object-shorthand\": \"off\",\n        \"one-var\": \"off\",\n        \"one-var-declaration-per-line\": [\n            \"error\",\n            \"initializations\"\n        ],\n        \"operator-assignment\": [\n            \"error\",\n            \"always\"\n        ],\n        \"operator-linebreak\": \"error\",\n        \"padded-blocks\": \"off\",\n        \"prefer-arrow-callback\": \"off\",\n        \"prefer-const\": \"error\",\n        \"prefer-reflect\": \"off\",\n        \"prefer-rest-params\": \"off\",\n        \"prefer-spread\": \"off\",\n        \"prefer-template\": \"off\",\n        \"quote-props\": \"off\",\n        \"quotes\": \"off\",\n        \"radix\": \"error\",\n        \"require-jsdoc\": \"off\",\n        \"rest-spread-spacing\": \"error\",\n        \"semi\": \"off\",\n        \"semi-spacing\": [\n            \"error\",\n            {\n                \"after\": true,\n                \"before\": false\n            }\n        ],\n        \"sort-imports\": \"error\",\n        \"sort-keys\": \"off\",\n        \"sort-vars\": \"off\",\n        \"space-before-blocks\": \"error\",\n        \"space-before-function-paren\": \"off\",\n        \"space-in-parens\": \"off\",\n        \"space-infix-ops\": \"error\",\n        \"space-unary-ops\": \"error\",\n        \"spaced-comment\": [\n            \"error\",\n            \"always\"\n        ],\n        \"strict\": [\n            \"error\",\n            \"never\"\n        ],\n        \"symbol-description\": \"error\",\n        \"template-curly-spacing\": \"error\",\n        \"unicode-bom\": [\n            \"error\",\n            \"never\"\n        ],\n        \"valid-jsdoc\": \"error\",\n        \"vars-on-top\": \"off\",\n        \"wrap-iife\": \"error\",\n        \"wrap-regex\": \"error\",\n        \"yield-star-spacing\": \"error\",\n        \"yoda\": [\n            \"error\",\n            \"never\"\n        ]\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/gulpfile.js":"var gulp = require( \"gulp\" );\nvar bg = require( \"biggulp\" )( gulp );\n\ngulp.task( \"coverage\", bg.withCoverage() );\n\ngulp.task( \"coverage-watch\", function() {\n\tbg.watch( [ \"coverage\" ] );\n} );\n\ngulp.task( \"default\", [ \"coverage\", \"coverage-watch\" ] );\ngulp.task( \"test\", [ \"coverage\" ] );\ngulp.task( \"show-coverage\", function() {\n    return bg.showCoverage();\n} );\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/ackBatch.js":"var _ = require( \"lodash\" );\nvar postal = require( \"postal\" );\nvar Monologue = require( \"monologue.js\" );\nvar signal = postal.channel( \"rabbit.ack\" );\nvar log = require( \"./log.js\" )( \"rabbot.acknack\" );\n\n/* log\n\t* `rabbot.acknack`\n\t  * `debug`\n\t    * resolution operation on a series of tags\n\t    * resolution operation on ALL tags\n\t    * queue has no pending tags\n\t    * new pending tag added\n\t    * user performed message operation\n\t  * `error`\n\t    * message operation failed\n*/\n\nvar calls = {\n\tack: \"_ack\",\n\tnack: \"_nack\",\n\treject: \"_reject\"\n};\n\nvar AckBatch = function( name, connectionName, resolver ) {\n\tthis.name = name;\n\tthis.connectionName = connectionName;\n\tthis.resolver = resolver;\n\tthis.reset();\n};\n\nAckBatch.prototype._ack = function( tag, inclusive ) {\n\tthis.lastAck = tag;\n\tthis._resolveTag( tag, \"ack\", inclusive );\n};\n\nAckBatch.prototype._ackOrNackSequence = function() {\n\ttry {\n\t\tvar firstMessage = this.messages[ 0 ];\n\t\tif ( firstMessage === undefined ) {\n\t\t\treturn;\n\t\t}\n\t\tvar firstStatus = firstMessage.status;\n\t\tvar sequenceEnd = firstMessage.tag;\n\t\tvar call = calls[ firstStatus ];\n\t\tif ( firstStatus === \"pending\" ) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tfor (var i = 1; i < _.size( this.messages ) - 1; i++) {\n\t\t\t\tif ( this.messages[ i ].status !== firstStatus ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsequenceEnd = this.messages[ i ].tag;\n\t\t\t}\n\t\t\tif ( call ) {\n\t\t\t\tthis[ call ]( sequenceEnd, true );\n\t\t\t}\n\t\t}\n\t} catch ( err ) {\n\t\tlog.error( \"An exception occurred while trying to resolve ack/nack sequence on %s - %s: %s\", this.name, this.connectionName, err.stack );\n\t}\n};\n\nAckBatch.prototype._firstByStatus = function( status ) {\n\treturn _.find( this.messages, { status: status } );\n};\n\nAckBatch.prototype._lastByStatus = function( status ) {\n\treturn _.findLast( this.messages, { status: status } );\n};\n\nAckBatch.prototype._nack = function( tag, inclusive ) {\n\tthis.lastNack = tag;\n\tthis._resolveTag( tag, \"nack\", inclusive );\n};\n\nAckBatch.prototype._reject = function( tag, inclusive ) {\n\tthis.lastReject = tag;\n\tthis._resolveTag( tag, \"reject\", inclusive );\n};\n\nAckBatch.prototype._processBatch = function() {\n\tthis.acking = this.acking !== undefined ? this.acking : false;\n\tif ( !this.acking ) {\n\t\tthis.acking = true;\n\t\tvar hasPending = ( _.findIndex( this.messages, { status: \"pending\" } ) >= 0 );\n\t\tvar hasAck = this.firstAck;\n\t\tvar hasNack = this.firstNack;\n\t\tvar hasReject = this.firstReject;\n\t\t// just acks\n\t\tif ( !hasPending && !hasNack && hasAck && !hasReject ) {\n\t\t\tthis._resolveAll( \"ack\", \"firstAck\", \"lastAck\" );\n\t\t}\n\t\t// just nacks\n\t\telse if ( !hasPending && hasNack && !hasAck && !hasReject ) {\n\t\t\tthis._resolveAll( \"nack\", \"firstNack\", \"lastNack\" );\n\t\t}\n\t\t// just rejects\n\t\telse if ( !hasPending && !hasNack && !hasAck && hasReject ) {\n\t\t\tthis._resolveAll( \"reject\", \"firstReject\", \"lastReject\" );\n\t\t}\n\t\t// acks, nacks or rejects\n\t\telse if ( hasNack || hasAck || hasReject ) {\n\t\t\tthis._ackOrNackSequence();\n\t\t\tthis.acking = false;\n\t\t}\n\t\t// nothing to do\n\t\telse {\n\t\t\tthis.resolver( \"waiting\" );\n\t\t\tthis.acking = false;\n\t\t}\n\t}\n};\n\nAckBatch.prototype._resolveAll = function( status, first, last ) {\n\tvar count = this.messages.length;\n\tvar emitEmpty = function() {\n\t\t// process.nextTick( function() {\n    setTimeout( function() {\n\t\t\tthis.emit( \"empty\" );\n\t\t}.bind( this ), 10 );\n\t}.bind( this );\n\tif ( this.messages.length !== 0 ) {\n\t\tvar lastTag = this._lastByStatus( status ).tag;\n\t\tlog.debug( \"%s ALL (%d) tags on %s up to %d - %s.\",\n\t\t\tstatus,\n\t\t\tthis.messages.length,\n\t\t\tthis.name,\n      lastTag,\n\t\t\tthis.connectionName );\n\t\tthis.resolver( status, { tag: lastTag, inclusive: true } )\n\t\t\t.then( function() {\n\t\t\t\tthis[ last ] = lastTag;\n\t\t\t\tthis._removeByStatus( status );\n\t\t\t\tthis[ first ] = undefined;\n\t\t\t\tif ( count > 0 && this.messages.length === 0 ) {\n\t\t\t\t\tlog.debug( \"No pending tags remaining on queue %s - %s\", this.name, this.connectionName );\n\t\t\t\t\t// The following setTimeout is the only thing between an insideous heisenbug and your sanity:\n\t\t\t\t\t// The promise for ack/nack will resolve on the channel before the server has processed it.\n\t\t\t\t\t// Without the setTimeout, if there is a pending cleanup/shutdown on the channel from the queueFsm,\n\t\t\t\t\t// the channel close will complete and cause the server to ignore the outstanding ack/nack command.\n\t\t\t\t\t// I lost HOURS on this because doing things that slow down the processing of the close cause\n\t\t\t\t\t// the bug to disappear.\n\t\t\t\t\t// Hackfully yours,\n\t\t\t\t\t// Alex\n\t\t\t\t\temitEmpty();\n\t\t\t\t}\n\t\t\t\tthis.acking = false;\n\t\t\t}.bind( this ) );\n\t}\n};\n\nAckBatch.prototype._resolveTag = function( tag, operation, inclusive ) {\n\tvar removed = this._removeUpToTag( tag );\n\tvar nextAck = this._firstByStatus( \"ack\" );\n\tvar nextNack = this._firstByStatus( \"nack\" );\n\tvar nextReject = this._firstByStatus( \"reject\" );\n\tthis.firstAck = nextAck ? nextAck.tag : undefined;\n\tthis.firstNack = nextNack ? nextNack.tag : undefined;\n\tthis.firstReject = nextReject ? nextReject.tag : undefined;\n\tlog.debug( \"%s %d tags (%s) on %s - %s. (Next ack: %d, Next nack: %d, Next reject: %d)\",\n\t\toperation,\n\t\tremoved.length,\n\t\tinclusive ? \"inclusive\" : \"individual\",\n\t\tthis.name,\n\t\tthis.connectionName,\n\t\tthis.firstAck || 0,\n\t\tthis.firstNack || 0,\n\t\tthis.firstReject || 0 );\n\tthis.resolver( operation, { tag: tag, inclusive: inclusive } );\n};\n\nAckBatch.prototype._removeByStatus = function( status ) {\n\treturn _.remove( this.messages, function( message ) {\n\t\treturn message.status === status;\n\t} );\n};\n\nAckBatch.prototype._removeUpToTag = function( tag ) {\n\treturn _.remove( this.messages, function( message ) {\n\t\treturn message.tag <= tag;\n\t} );\n};\n\nAckBatch.prototype.addMessage = function( message ) {\n\tthis.receivedCount++;\n\tvar status = message.message || message;\n\tthis.messages.push( status );\n\tlog.debug( \"New pending tag %d on queue %s - %s\", status.tag, this.name, this.connectionName );\n};\n\nAckBatch.prototype.changeName = function( name ) {\n  this.name = name;\n};\n\nAckBatch.prototype.getMessageOps = function( tag ) {\n\tvar message = {\n\t\ttag: tag,\n\t\tstatus: \"pending\"\n\t};\n\treturn {\n\t\tmessage: message,\n\t\tack: function() {\n\t\t\tlog.debug( \"Marking tag %d as ack'd on queue %s - %s\", tag, this.name, this.connectionName );\n\t\t\tthis.firstAck = this.firstAck || tag;\n\t\t\tmessage.status = \"ack\";\n\t\t}.bind( this ),\n\t\tnack: function() {\n\t\t\tlog.debug( \"Marking tag %d as nack'd on queue %s - %s\", tag, this.name, this.connectionName );\n\t\t\tthis.firstNack = this.firstNack || tag;\n\t\t\tmessage.status = \"nack\";\n\t\t}.bind( this ),\n\t\treject: function() {\n\t\t\tlog.debug( \"Marking tag %d as rejected on queue %s - %s\", tag, this.name, this.connectionName );\n\t\t\tthis.firstReject = this.firstReject || tag;\n\t\t\tmessage.status = \"reject\";\n\t\t}.bind( this )\n\t};\n};\n\nAckBatch.prototype.ignoreSignal = function() {\n\tif ( this.signalSubscription ) {\n\t\tthis.signalSubscription.unsubscribe();\n\t}\n};\n\nAckBatch.prototype.listenForSignal = function() {\n\tif ( !this.signalSubscription ) {\n\t\tthis.signalSubscription = signal.subscribe( \"#\", function() {\n\t\t\tthis._processBatch();\n\t\t}.bind( this ) );\n\t}\n};\n\nAckBatch.prototype.reset = function() {\n\tthis.lastAck = -1;\n\tthis.lastNack = -1;\n\tthis.lastReject = -1;\n\tthis.firstAck = undefined;\n\tthis.firstNack = undefined;\n\tthis.firstReject = undefined;\n\tthis.messages = [];\n\tthis.receivedCount = 0;\n};\n\nMonologue.mixInto( AckBatch );\n\nmodule.exports = AckBatch;\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/exchangeFsm.js":"var _ = require( \"lodash\" );\nvar when = require( \"when\" );\nvar machina = require( \"machina\" );\nvar Monologue = require( \"monologue.js\" );\nvar publishLog = require( \"./publishLog\" );\nvar exLog = require( \"./log.js\" )( \"rabbot.exchange\" );\nvar format = require( \"util\" ).format;\n\n/* log\n\t* `rabbot.exchange`\n\t  * `debug`:\n\t    * release called\n\t\t* publish called\n\t  * `warn`:\n\t    * exchange was released with unconfirmed messages\n\t\t* on publish to released exchange\n\t\t* publish is rejected because exchange has reached the limit because of pending connection\n */\n\nfunction unhandle( handlers ) {\n  _.each( handlers, function( handle ) {\n    handle.unsubscribe();\n  } );\n}\n\nvar Factory = function( options, connection, topology, serializers, exchangeFn ) {\n\n\t// allows us to optionally provide a mock\n\texchangeFn = exchangeFn || require( \"./amqp/exchange\" );\n\n\tvar Fsm = machina.Fsm.extend( {\n\t\tname: options.name,\n\t\ttype: options.type,\n\t\tpublishTimeout: options.publishTimeout || 0,\n\t\treplyTimeout: options.replyTimeout || 0,\n\t\tlimit: ( options.limit || 100 ),\n    publisher: undefined,\n\t\treleasers: [],\n\t\tdeferred: [],\n\t\tpublished: publishLog(),\n\n\t\t_define: function( exchange, stateOnDefined ) {\n\t\t\tfunction onDefinitionError( err ) {\n        this.failedWith = err;\n\t\t\t\tthis.transition( \"failed\" );\n\t\t\t}\n\t\t\tfunction onDefined() {\n\t\t\t\tthis.transition( stateOnDefined );\n\t\t\t}\n\t\t\texchange.define()\n\t\t\t\t.then( onDefined.bind( this ), onDefinitionError.bind( this ) );\n\t\t},\n\n\t\t_listen: function() {\n\t\t\tconnection.on( \"unreachable\", function( err ) {\n        err = err || new Error( \"Could not establish a connection to any known nodes.\" );\n        this._onFailure( err );\n        this.transition( \"unreachable\" );\n      }.bind( this ) );\n\t\t},\n\n\t\t_onAcquisition: function( transitionTo, exchange ) {\n      var handlers = [];\n\n\t\t\thandlers.push( exchange.channel.once( \"released\", function() {\n\t\t\t\tthis.handle( \"released\", exchange );\n\t\t\t}.bind( this ) ) );\n\n      handlers.push( exchange.channel.once( \"closed\", function() {\n\t\t\t\tthis.handle( \"closed\", exchange );\n\t\t\t}.bind( this ) ) );\n\n      function cleanup() {\n        unhandle( handlers );\n        exchange.release()\n          .then( function() {\n              this.transition( \"released\" );\n            }.bind( this )\n          );\n      }\n\n      function onCleanupError() {\n        var count = this.published.count();\n        if ( count > 0 ) {\n          exLog.warn( \"%s exchange '%s', connection '%s' was released with %d messages unconfirmed\",\n            this.type,\n            this.name,\n            connection.name,\n            count );\n        }\n        cleanup.bind( this )();\n      }\n\n      var releaser = function() {\n        return this.published.onceEmptied()\n          .then( cleanup.bind( this ), onCleanupError.bind( this ) );\n      }.bind( this );\n\n      var publisher = function( message ) {\n        return exchange.publish( message )\n      }.bind( this );\n\n      this.publisher = publisher;\n      this.releasers.push( releaser );\n\t\t\tthis._define( exchange, transitionTo );\n\t\t},\n\n\t\t_onFailure: function( err ) {\n\t\t\tthis.failedWith = err;\n\t\t\t_.each( this.deferred, function( x ) {\n\t\t\t\tx( err );\n\t\t\t} );\n\t\t\tthis.deferred = [];\n\t\t\tthis.published.reset();\n\t\t},\n\n\t\t_removeDeferred: function( reject ) {\n\t\t\tvar index = _.indexOf( this.deferred, reject );\n\t\t\tif ( index >= 0 ) {\n\t\t\t\tthis.deferred.splice( index, 1 );\n\t\t\t}\n\t\t},\n\n    _release: function( closed ) {\n      var release = this.releasers.shift();\n      if( release ) {\n        return release( closed );\n      } else {\n        return when();\n      }\n    },\n\n\t\tcheck: function() {\n\t\t\tvar deferred = when.defer();\n\t\t\tthis.handle( \"check\", deferred );\n\t\t\treturn deferred.promise;\n\t\t},\n\n\t\trelease: function() {\n\t\t\texLog.debug( \"Release called on exchange %s - %s (%d messages pending)\", this.name, connection.name, this.published.count() );\n\t\t\treturn when.promise( function( resolve ) {\n\t\t\t\tthis.once( \"released\", function() {\n\t\t\t\t\tresolve();\n\t\t\t\t} );\n\t\t\t\tthis.handle( \"release\" );\n\t\t\t}.bind( this ) );\n\t\t},\n\n\t\tpublish: function( message ) {\n\t\t\tif( this.state !== \"ready\" && this.published.count() >= this.limit ) {\n\t\t\t\texLog.warn( \"Exchange '%s' has reached the limit of %d messages waiting on a connection\",\n\t\t\t\t\tthis.name,\n\t\t\t\t\tthis.limit\n\t\t\t\t);\n\t\t\t\treturn when.reject( \"Exchange has reached the limit of messages waiting on a connection\" );\n\t\t\t}\n\t\t\tvar publishTimeout = message.timeout || options.publishTimeout || message.connectionPublishTimeout || 0;\n\t\t\treturn when.promise( function( resolve, reject ) {\n\t\t\t\tvar timeout, timedOut, failedSub;\n\t\t\t\tif( publishTimeout > 0 ) {\n\t\t\t\t\ttimeout = setTimeout( function() {\n\t\t\t\t\t\ttimedOut = true;\n\t\t\t\t\t\tonRejected.bind( this )( new Error( \"Publish took longer than configured timeout\" ) );\n\t\t\t\t\t}.bind( this ), publishTimeout );\n\t\t\t\t}\n\t\t\t\tfunction onPublished() {\n\t\t\t\t\tresolve();\n\t\t\t\t\tthis._removeDeferred( reject );\n\t\t\t\t\tfailedSub.unsubscribe();\n\t\t\t\t}\n\t\t\t\tfunction onRejected( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t\tthis._removeDeferred( reject );\n\t\t\t\t\tfailedSub.unsubscribe();\n\t\t\t\t}\n\t\t\t\tvar op = function( err ) {\n\t\t\t\t\tif( err ) {\n\t\t\t\t\t\tonRejected.bind( this )( err );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif( timeout ) {\n\t\t\t\t\t\t\tclearTimeout( timeout );\n\t\t\t\t\t\t\ttimeout = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( !timedOut ) {\n\t\t\t\t\t\t\treturn this.publisher( message )\n\t\t\t\t\t\t\t\t.then( onPublished.bind( this ), onRejected.bind( this ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.bind( this );\n\t\t\t\tfailedSub = this.once( \"failed\", function( err ) {\n\t\t\t\t\tonRejected.bind( this )( err );\n\t\t\t\t}.bind( this ) );\n\t\t\t\tthis.deferred.push( reject );\n\t\t\t\tthis.handle( \"publish\", op );\n\t\t\t}.bind( this ) );\n\t\t},\n\n\t\tretry: function() {\n\t\t\tthis.transition( 'initializing' );\n\t\t},\n\n\t\tinitialState: \"setup\",\n\t\tstates: {\n\t\t\tclosed: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.emit( \"closed\" );\n\t\t\t\t},\n\t\t\t\tcheck: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"ready\" );\n\t\t\t\t\tthis.transition( \"initializing\" );\n\t\t\t\t},\n\t\t\t\tpublish: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"ready\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tfailed: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis._onFailure( this.failedWith );\n\t\t\t\t\tthis.emit( \"failed\", this.failedWith );\n\t\t\t\t},\n\t\t\t\tcheck: function( deferred ) {\n\t\t\t\t\tdeferred.reject( this.failedWith );\n\t\t\t\t\tthis.emit( \"failed\", this.failedWith );\n\t\t\t\t},\n\t\t\t\trelease: function( exchange ) {\n          this._release( exchange )\n            .then( function() {\n              this.transition( \"released\" );\n            }.bind( this ) );\n\t\t\t\t},\n\t\t\t\tpublish: function( op ) {\n\t\t\t\t\top( this.failedWith );\n\t\t\t\t}\n\t\t\t},\n\t\t\tinitializing: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\texchangeFn( options, topology, this.published, serializers )\n\t\t\t\t\t\t.then( function( exchange ) {\n\t\t\t\t\t\t\tthis.handle( \"acquired\", exchange );\n\t\t\t\t\t\t}.bind( this ) );\n\t\t\t\t},\n\t\t\t\tacquired: function( exchange ) {\n\t\t\t\t\tthis._onAcquisition( \"ready\", exchange );\n\t\t\t\t},\n\t\t\t\tcheck: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"ready\" );\n\t\t\t\t},\n\t\t\t\tclosed: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"ready\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"ready\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\tthis.transition( \"initializing\" );\n\t\t\t\t},\n\t\t\t\tpublish: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"ready\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tready: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.emit( \"defined\" );\n\t\t\t\t},\n\t\t\t\tcheck: function( deferred ) {\n\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\tthis.emit( \"defined\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"released\" );\n\t\t\t\t\tthis.transition( \"releasing\" );\n\t\t\t\t},\n\t\t\t\tclosed: function() {\n\t\t\t\t\tthis.transition( \"closed\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"releasing\" );\n\t\t\t\t},\n\t\t\t\tpublish: function( op ) {\n\t\t\t\t\top();\n\t\t\t\t}\n\t\t\t},\n\t\t\treleasing: {\n\t\t\t\t_onEnter: function() {\n          this._release()\n            .then( function() {\n              this.transition( \"released\" );\n            }.bind( this ) );\n\t\t\t\t},\n\t\t\t\tpublish: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"released\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"released\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\treleased: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.emit( \"released\" );\n\t\t\t\t},\n\t\t\t\tcheck: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"ready\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.emit( \"released\" );\n\t\t\t\t},\n\t\t\t\tpublish: function( op ) {\n\t\t\t\t\texLog.warn( \"Publish called on exchange '%s' after connection was released intentionally. Released connections must be re-established explicitly.\", this.name );\n\t\t\t\t\top( new Error( format( \"Cannot publish to exchange '%s' after intentionally closing its connection\", this.name ) ) );\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetup: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis._listen();\n\t\t\t\t\tthis.transition( \"initializing\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunreachable: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.emit( \"failed\", this.failedWith );\n\t\t\t\t},\n\t\t\t\tcheck: function( deferred ) {\n\t\t\t\t\tdeferred.reject( this.failedWith );\n\t\t\t\t\tthis.emit( \"failed\", this.failedWith );\n\t\t\t\t},\n\t\t\t\tpublish: function( op ) {\n\t\t\t\t\top( this.failedWith );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\tMonologue.mixInto( Fsm );\n\tvar fsm = new Fsm();\n\tconnection.addExchange( fsm );\n\treturn fsm;\n};\n\nmodule.exports = Factory;\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/publishLog.js":"var _ = require( \"lodash\" );\nvar when = require( \"when\" );\n\nfunction add( state, m ) {\n\tif ( !state.messages.sequenceNo ) {\n\t\tvar mSeq = next( state );\n\t\tm.sequenceNo = mSeq;\n\t\tstate.messages[ mSeq ] = m;\n\t}\n}\n\nfunction next( state ) {\n\tstate.count++;\n\treturn ( state.sequenceNumber++ );\n}\n\nfunction getEmptyPromise( state ) {\n\tif( state.count ) {\n\t\tvar deferred = when.defer();\n\t\tstate.waiting = deferred;\n\t\treturn deferred.promise;\n\t} else {\n\t\treturn when.resolve();\n\t}\t\n}\n\nfunction resolveWaiting( state ) {\n\tif( state.waiting ) {\n\t\tsetTimeout( function() {\n\t\t\tstate.waiting.resolve( state.count );\n\t\t\tstate.waiting = undefined;\n\t\t}, state.sequenceNumber );\n\t}\n}\n\nfunction rejectWaiting( state ) {\n\tif( state.waiting ) {\n\t\tstate.waiting.reject();\n\t\tstate.waiting = undefined;\n\t}\n}\n\nfunction remove( state, m ) {\n\tvar mSeq = m.sequenceNo !== undefined ? m.sequenceNo : m;\n\tvar removed = false;\n\tif ( state.messages[ mSeq ] ) {\n\t\tdelete state.messages[ mSeq ];\n\t\tstate.count--;\n\t\tremoved = true;\n\t}\n\tif( state.count === 0 ) {\n\t\tresolveWaiting( state );\n\t}\n\treturn removed;\n}\n\nfunction reset( state ) {\n\tvar list = _.map( state.messages, function( m ) {\n\t\tdelete m.sequenceNo;\n\t\treturn m;\n\t} );\n\tstate.sequenceNumber = 0;\n\tstate.messages = {};\n\tstate.count = 0;\n\trejectWaiting( state );\n\treturn list;\n}\n\n\nfunction publishLog() {\n\tvar state = {\n\t\tcount: 0,\n\t\tmessages: {},\n\t\tsequenceNumber: 0,\n\t\twaiting: undefined\n\t};\n\n\treturn {\n\t\tadd: add.bind( undefined, state ),\n\t\tcount: function() {\n\t\t\treturn Object.keys( state.messages ).length;\n\t\t},\n\t\tonceEmptied: getEmptyPromise.bind( undefined, state ),\n\t\treset: reset.bind( undefined, state ),\n\t\tremove: remove.bind( undefined, state ),\n\t\tstate: state\n\t};\n}\n\nmodule.exports = publishLog;\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/queueFsm.js":"var _ = require( \"lodash\" );\nvar when = require( \"when\" );\nvar machina = require( \"machina\" );\nvar format = require( \"util\" ).format;\nvar Monologue = require( \"monologue.js\" );\nMonologue.mixInto( machina.Fsm );\nvar log = require( \"./log.js\" )( \"rabbot.queue\" );\n\n/* log\n  * `rabbot.queue`\n    * `debug`\n      * release called\n    * `info`\n      * subscription started\n      * queue released\n    * `warn`\n      * queue released with pending messages\n*/\n\nfunction unhandle( handlers ) {\n  _.each( handlers, function( handle ) {\n    handle.unsubscribe();\n  } );\n}\n\nvar Factory = function( options, connection, topology, serializers, queueFn ) {\n\n  // allows us to optionally provide a mock\n  queueFn = queueFn || require( \"./amqp/queue\" );\n\n  var Fsm = machina.Fsm.extend( {\n    name: options.name,\n    responseSubscriptions: {},\n    signalSubscription: undefined,\n    subscriber: undefined,\n    unsubscribers: [],\n    releasers: [],\n\n    _define: function( queue ) {\n      var onError = function( err ) {\n        this.failedWith = err;\n        this.transition( \"failed\" );\n      }.bind( this );\n      var onDefined = function( defined ) {\n        if( !this.name ) {\n          this.name = defined.queue;\n          options.name = defined.queue;\n          queue.messages.changeName( this.name );\n          topology.renameQueue( defined.queue );\n        }\n        this.transition( \"ready\" );\n      }.bind( this );\n      queue.define()\n        .then( onDefined, onError );\n    },\n\n    _listen: function( queue ) {\n      var handlers = [];\n      var emit = this.emit.bind( this );\n\n      var unsubscriber = function() {\n        return queue.unsubscribe();\n      }.bind( this );\n\n      var onSubscribe = function() {\n        emit( \"subscribed\", {} );\n        log.info( \"Subscription to (%s) queue %s - %s started with consumer tag %s\",\n                options.noAck ? \"untracked\" : \"tracked\",\n                options.name,\n                connection.name,\n                queue.channel.tag );\n        this.unsubscribers.push( unsubscriber );\n        this.transition( \"subscribed\" );\n      }.bind( this );\n\n      var subscriber = function( exclusive ) {\n        return queue\n          .subscribe( !!exclusive )\n          .then( onSubscribe )\n          .catch( function( err ) {\n            emit( \"subscribeFailed\", err );\n          } );\n      };\n\n      var releaser = function( closed ) {\n        // remove handlers established on queue\n        unhandle( handlers );\n        if( queue && queue.getMessageCount() > 0 ) {\n          log.warn( \"!!! Queue %s - %s was released with %d pending messages !!!\",\n            options.name, connection.name, queue.getMessageCount() );\n        } else if( queue ) {\n          log.info( \"Released queue %s - %s\", options.name, connection.name );\n        }\n\n        if( !closed ) {\n          queue.release()\n            .then( function() {\n              this.handle( \"released\" );\n            }.bind( this ) );\n        }\n      }.bind( this );\n\n      this.subscriber = subscriber;\n      this.releasers.push( releaser );\n\n      handlers.push( queue.channel.on( \"acquired\", function() {\n          this._define( queue );\n        }.bind( this ) )\n      );\n      handlers.push( queue.channel.on( \"released\", function() {\n          this.handle( \"released\", queue );\n        }.bind( this ) )\n      );\n      handlers.push( queue.channel.on( \"closed\", function() {\n          this.handle( \"closed\", queue );\n        }.bind( this ) )\n      );\n      handlers.push( connection.on( \"unreachable\", function( err ) {\n          err = err || new Error( \"Could not establish a connection to any known nodes.\" );\n          this.handle( \"unreachable\", queue );\n        }.bind( this ) )\n      );\n\n      if( options.subscribe ) {\n        this.handle( \"subscribe\" );\n      }\n    },\n\n    _release: function( closed ) {\n      var release = this.releasers.shift();\n      if( release ) {\n        release( closed );\n      } else {\n        return when();\n      }\n    },\n\n    check: function() {\n      var deferred = when.defer();\n      this.handle( \"check\", deferred );\n      return deferred.promise;\n    },\n\n    release: function() {\n      return when.promise( function( resolve, reject ) {\n        var _handlers;\n        function cleanResolve() {\n          unhandle( _handlers );\n          resolve();\n        }\n        function cleanReject( err ) {\n          unhandle( _handlers );\n          reject( err );\n        }\n        _handlers = [\n          this.once( \"released\", cleanResolve ),\n          this.once( \"failed\", cleanReject ),\n          this.once( \"unreachable\", cleanReject ),\n          this.once( \"noqueue\", cleanResolve )\n        ];\n        this.handle( \"release\" );\n      }.bind( this ) );\n    },\n\n    retry: function() {\n      this.transition( 'initializing' );\n    },\n\n    subscribe: function( exclusive ) {\n      options.subscribe = true;\n      options.exclusive = exclusive;\n      return when.promise( function( resolve, reject ) {\n        var _handlers;\n        function cleanResolve() {\n          unhandle( _handlers );\n          resolve();\n        }\n        function cleanReject( err ) {\n          unhandle( _handlers );\n          this.transition( \"failed\" );\n          reject( err );\n        }\n        _handlers = [\n          this.once( \"subscribed\", cleanResolve ),\n          this.once( \"subscribeFailed\", cleanReject.bind( this ) ),\n          this.once( \"failed\", cleanReject.bind( this ) )\n        ];\n        this.handle( \"subscribe\" );\n      }.bind( this ) );\n    },\n\n    unsubscribe: function() {\n      options.subscribe = false;\n      var unsubscriber = this.unsubscribers.shift();\n      if( unsubscriber ) {\n        return unsubscriber();\n      } else {\n        return when.reject( new Error( \"No active subscription presently exists on the queue\" ) );\n      }\n    },\n\n    initialState: \"initializing\",\n    states: {\n      closed: {\n        _onEnter: function() {\n          this._release( true );\n          this.emit( \"closed\" );\n        },\n        check: function() {\n          this.deferUntilTransition( \"ready\" );\n          this.transition( \"initializing\" );\n        },\n        subscribe: function() {\n          this.deferUntilTransition( \"ready\" );\n        }\n      },\n      failed: {\n        _onEnter: function() {\n          this.emit( \"failed\", this.failedWith );\n        },\n        check: function( deferred ) {\n          if( deferred ) {\n            deferred.reject( this.failedWith );\n          }\n          this.emit( \"failed\", this.failedWith );\n        },\n        release: function( queue ) {\n          if( queue ) {\n            this._removeHandlers();\n            queue.release()\n              .then( function() {\n                this.handle( \"released\", queue );\n              } );\n          }\n        },\n        released: function() {\n          this.transition( \"released\" );\n        },\n        subscribe: function() {\n          this.emit( \"subscribeFailed\", this.failedWith );\n        }\n      },\n      initializing: {\n        _onEnter: function() {\n          queueFn( options, topology, serializers )\n            .then( function( queue ) {\n              this.lastQueue = queue;\n              this.handle( \"acquired\", queue );\n            }.bind( this ) );\n        },\n        acquired: function( queue ) {\n          this.receivedMessages = queue.messages;\n          this._define( queue );\n          this._listen( queue );\n        },\n        check: function() {\n          this.deferUntilTransition( \"ready\" );\n        },\n        release: function() {\n          this.deferUntilTransition( \"ready\" );\n        },\n        closed: function() {\n          this.deferUntilTransition( \"ready\" );\n        },\n        subscribe: function() {\n          this.deferUntilTransition( \"ready\" );\n        }\n      },\n      ready: {\n        _onEnter: function() {\n          this.emit( \"defined\" );\n        },\n        check: function( deferred ) {\n          deferred.resolve();\n        },\n        closed: function() {\n          this.transition( \"closed\" );\n        },\n        release: function() {\n          this.transition( \"releasing\" );\n          this.handle( \"release\" )\n        },\n        released: function() {\n          this._release( true );\n          this.transition( \"initializing\" );\n        },\n        subscribe: function() {\n          if( this.subscriber ) {\n            this.transition( \"subscribing\" );\n      return  this.subscriber();\n          }\n        }\n      },\n      releasing: {\n        release: function() {\n          this._release( false );\n        },\n        released: function() {\n          this.transition( \"released\" );\n        }\n      },\n      released: {\n        _onEnter: function() {\n          this.emit( \"released\" );\n        },\n        release: function() {\n          this.emit( \"released\" );\n        },\n        check: function( deferred ) {\n          deferred.reject( new Error( format( \"Cannot establish queue '%s' after intentionally closing its connection\", this.name ) ) );\n        },\n        subscribe: function() {\n          this.emit( \"subscribeFailed\", new Error( format( \"Cannot subscribe to queue '%s' after intentionally closing its connection\", this.name ) ) );\n        }\n      },\n      subscribing: {\n        closed: function() {\n          this.transition( \"closed\" );\n        },\n        release: function() {\n          this.transition( \"releasing\" );\n          this.handle( \"release\" )\n        },\n        released: function() {\n          this._release( true );\n          this.transition( \"initializing\" );\n        },\n        subscribe: function() {\n          this.deferUntilTransition( \"subscribed\" );\n        }\n      },\n      subscribed: {\n        check: function( deferred ) {\n          deferred.resolve();\n        },\n        closed: function() {\n          this.transition( \"closed\" );\n        },\n        release: function() {\n          this.transition( \"releasing\" );\n          this.handle( \"release\" )\n        },\n        released: function() {\n          this._release( true );\n          this.transition( \"initializing\" );\n        },\n        subscribe: function() {\n          this.emit( \"subscribed\" );\n        }\n      },\n      unreachable: {\n        check: function( deferred ) {\n          deferred.reject( new Error( format( \"Cannot establish queue '%s' when no nodes can be reached\", this.name ) ) );\n        },\n        subscribe: function( sub ) {\n          this.emit( \"subscribeFailed\", new Error( format( \"Cannot subscribe to queue '%s' when no nodes can be reached\", this.name ) ) );\n        }\n      }\n    }\n  } );\n\n  var fsm = new Fsm();\n  connection.addQueue( fsm );\n  return fsm;\n};\n\nmodule.exports = Factory;\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/amqp/channel.js":"var AmqpChannel = require( \"amqplib/lib/callback_model\" ).Channel;\nvar monad = require( \"./iomonad.js\" );\nvar when = require( \"when\" );\nvar log = require( \"../log\" )( \"rabbot.channel\" );\n\n/* log\n\t* `rabbot.channel`\n\t  * `debug`\n\t    * when amqplib's `channel.close` promise is rejected\n*/\n\nfunction close( name, channel ) {\n\tif ( channel.close ) {\n\t\treturn channel.close()\n\t\t\t.then( null, function( err ) {\n\t\t\t\t// since calling close on channel could reject the promise\n\t\t\t\t// (see connection close's comment) this catches and logs it\n\t\t\t\t// for debug level\n\t\t\t\tlog.debug( \"Error was reported during close of connection `%s` - `%s`\", name, err );\n\t\t\t} );\n\t} else {\n\t\treturn when();\n\t}\n}\n\nmodule.exports = {\n\tcreate: function( connection, name, confirm ) {\n\t\tvar method = confirm ? \"createConfirmChannel\" : \"createChannel\";\n\t\tvar factory = function() {\n\t\t\treturn connection[ method ]();\n\t\t};\n\t\tvar channel = monad( name, \"channel\", factory, AmqpChannel, close.bind( null, name ) );\n\t\treturn channel;\n\t}\n};\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/amqp/iomonad.js":"// This is probably not a true monad, but it seems close based on my current understanding.\n\nvar _ = require( \"lodash\" );\nvar Monologue = require( \"monologue.js\" );\nvar when = require( \"when\" );\nvar machina = require( \"machina\" );\nvar log = require( \"../log.js\" )( \"rabbot.io\" );\nvar format = require( \"util\" ).format;\nvar staticId = 0;\n\n/* state definitions\n\tacquiring - waiting to get back a connection or channel\n\tacquired - an open connection or channel was established\n\tclosed - the broker closed the channel or connection\n\tfailed - a temporary state between retries\n\treleased - release happens due to user action _or_ after all attempts to connect are exhausted\n*/\n\n/* events emitted:\n\t`acquiring` - in the process of acquisition\n\t`acquired` - channel or connection is available\n\t`return` - published message was returned by AMQP\n\t`failed` - acquisition failed\n\t`closed` - broker terminated the connection or channel\n\t`released` - closed in response to a user action _or_ after exhausting allowed attempts\n*/\n\n/* log:\n\t* `rabbot.io`\n\t  * `debug`:\n\t    * attempting acquisition\n\t    * successful acquisition\n\t  * `info`:\n\t\t* closing due to a user call\n\t\t* operation is called on a closed resource\n\t  * `warn`:\n\t\t* closed by the broker\n\t\t* operation is called on a released resource\n\t\t* exception when calling built-in close\n\t\t* the channel/connection is blocked\n\t\t* the channel/connection is unblocked\n\t  * `error`:\n\t\t* failure due to protocol or connectivity\n\t\t* failure due to an exception (bad code)\n*/\n\nmodule.exports = function( name, type, factory, target, close ) {\n\tvar IOMonad = machina.Fsm.extend( {\n\t\tid: staticId++,\n\t\tinitialState: \"acquiring\",\n\t\titem: undefined,\n\t\twaitInterval: 0,\n\t\twaitMax: 5000,\n\t\teventHandlers: [],\n\t\t_acquire: function() {\n\t\t\tprocess.nextTick( function() {\n\t\t\t\tthis.emit( \"acquiring\" );\n\t\t\t}.bind( this ) );\n\t\t\tlog.debug( \"Attempting acquisition of %s '%s'\", type, name );\n\t\t\tfactory()\n\t\t\t\t.then(\n\t\t\t\t\tthis._onAcquisition.bind( this ),\n\t\t\t\t\tthis._onAcquisitionError.bind( this )\n\t\t\t\t);\n\t\t},\n\t\t_clearEventHandlers: function() {\n\t\t\tif( this.item ) {\n\t\t\t\tthis.item.removeAllListeners( \"blocked\" );\n\t\t\t\tthis.item.removeAllListeners( \"unblocked\" );\n\t\t\t}\n\t\t},\n\t\t_finalize: function() {\n\t\t\tif ( this.item && this.item.removeAllListeners ) {\n\t\t\t\tthis.item.removeAllListeners();\n\t\t\t}\n\t\t\tthis.item = null;\n\t\t},\n\t\t_onAcquisition: function( instance ) {\n\t\t\tthis.item = instance;\n\t\t\tthis.waitInterval = 0;\n\t\t\tlog.debug( \"Acquired %s '%s' successfully\", type, name );\n\t\t\t// amqplib primitives emit close and error events\n\t\t\tthis.item.on( \"return\", function(raw) {\n\t\t\t\tthis.handle( \"return\", raw );\n\t\t\t}.bind( this ) );\n\t\t\tthis.item.once( \"close\", function( info ) {\n\t\t\t\tinfo = info || \"No information provided\";\n\t\t\t\tthis._clearEventHandlers();\n\t\t\t\tthis.handle( \"released\", info );\n\t\t\t}.bind( this ) );\n\t\t\tthis.item.on( \"error\", function( err ) {\n\t\t\t\tlog.error( \"Error emitted by %s '%s' - '%s'\", type, name, err.stack );\n\t\t\t\tthis._clearEventHandlers();\n\t\t\t\tthis.emit( \"failed\", err );\n\t\t\t\tthis.handle( \"failed\", err );\n\t\t\t}.bind( this ) );\n\t\t\tthis.item\n\t\t\t\t.on( \"unblocked\", function() {\n\t\t\t\t\tlog.warn( \"%s '%s' was unblocked by the broker\", type, name );\n\t\t\t\t\tthis.emit( \"unblocked\" );\n\t\t\t\t\tthis.handle( \"unblocked\" );\n\t\t\t\t}.bind( this ) )\n\t\t\t\t.on( \"blocked\", function() {\n\t\t\t\t\tlog.warn( \"%s '%s' was blocked by the broker\", type, name );\n\t\t\t\t\tthis.emit( \"blocked\" );\n\t\t\t\t\tthis.handle( \"blocked\" );\n\t\t\t\t}.bind( this ) );\n\t\t\tthis.transition( \"acquired\" );\n\t\t},\n\t\t_onAcquisitionError: function ( err ) {\n\t\t\tlog.error( \"Acquisition of %s '%s' failed with '%s'\", type, name, err );\n\t\t\tthis.emit( \"failed\", err );\n\t\t\tthis.handle( \"failed\" );\n\t\t},\n\t\t_release: function() {\n\t\t\tif( this.retry ) {\n\t\t\t\tclearTimeout( this.retry );\n\t\t\t}\n\t\t\tif ( this.item ) {\n\t\t\t\t// go through close procedure for resource\n\t\t\t\tif ( close ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tclose( this.item );\n\t\t\t\t\t} catch ( ex ) {\n\t\t\t\t\t\tlog.warn( \"%s '%s' threw an exception on close: %s\", type, name, ex );\n\t\t\t\t\t\tthis.handle( \"released\" );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.item.close();\n\t\t\t\t\t} catch ( ex ) {\n\t\t\t\t\t\tlog.warn( \"%s '%s' threw an exception on close: %s\", type, name, ex );\n\t\t\t\t\t\tthis.handle( \"released\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.handle( \"released\" );\n\t\t\t}\n\t\t},\n\t\tacquire: function() {\n\t\t\tthis.handle( \"acquire\" );\n\t\t\treturn when.promise( function( resolve, reject ) {\n\t\t\t\tthis.once( \"acquired\", function() {\n\t\t\t\t\tresolve( this );\n\t\t\t\t}.bind( this ) );\n\t\t\t\tthis.once( \"released\", function() {\n\t\t\t\t\treject( new Error( format( \"Cannot reacquire released %s '%s'\", type, name ) ) );\n\t\t\t\t} );\n\t\t\t}.bind( this ) );\n\t\t},\n\t\toperate: function( call, args ) {\n\t\t\tvar op = { operation: call, argList: args, index: this.index },\n\t\t\t\tpromise = when.promise( function( resolve, reject ) {\n\t\t\t\t\top.resolve = resolve;\n\t\t\t\t\top.reject = reject;\n\t\t\t\t} );\n\t\t\tthis.handle( \"operate\", op );\n\t\t\treturn promise.then( null, function( err ) {\n\t\t\t\treturn when.reject( err );\n\t\t\t} );\n\t\t},\n\t\trelease: function() {\n\t\t\tif ( this.retry ) {\n\t\t\t\tclearTimeout( this.retry );\n\t\t\t}\n\t\t\treturn when.promise( function( resolve ) {\n\t\t\t\tthis.once( \"released\", function() {\n\t\t\t\t\tresolve();\n\t\t\t\t} );\n\t\t\t\tthis.handle( \"release\" );\n\t\t\t}.bind( this ) );\n\t\t},\n\t\tstates: {\n\t\t\tacquiring: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis._acquire();\n\t\t\t\t},\n\t\t\t\tblocked: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"acquired\" );\n\t\t\t\t},\n\t\t\t\tfailed: function() {\n\t\t\t\t\tthis.transition( \"failed\" );\n\t\t\t\t},\n\t\t\t\toperate: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"acquired\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.transition( \"released\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\tthis.transition( \"released\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tacquired: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.emit( \"acquired\" );\n\t\t\t\t},\n\t\t\t\tacquire: function() {\n\t\t\t\t\tthis.emit( \"acquired\" );\n\t\t\t\t},\n\t\t\t\treturn: function(raw) {\n\t\t\t\t\tthis.emit( \"return\", raw);\n\t\t\t\t},\n\t\t\t\tblocked: function() {\n\t\t\t\t\tthis.transition( \"blocked\" );\n\t\t\t\t},\n\t\t\t\tfailed: function() {\n\t\t\t\t\tthis.transition( \"failed\" );\n\t\t\t\t},\n\t\t\t\toperate: function( call ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar result = this.item[ call.operation ].apply( this.item, call.argList );\n\t\t\t\t\t\tif ( result && result.then ) {\n\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t.then( call.resolve, call.reject );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcall.resolve( result );\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tcall.reject( err );\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\t// the user has called release during acquired state\n\t\t\t\t\tlog.info( \"%s '%s' was closed by the user\",\n\t\t\t\t\t\ttype, name );\n\t\t\t\t\tthis.transition( \"releasing\" );\n\t\t\t\t},\n\t\t\t\treleased: function( reason ) {\n\t\t\t\t\t// the remote end initiated close\n\t\t\t\t\tlog.warn( \"%s '%s' was closed by the broker with reason '%s'\",\n\t\t\t\t\t\ttype, name, reason );\n\t\t\t\t\tthis.closeReason = reason;\n\t\t\t\t\tthis.transition( \"closed\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tblocked: {\n\t\t\t\tfailed: function() {\n\t\t\t\t\tthis.transition( \"failed\" );\n\t\t\t\t},\n\t\t\t\toperate: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"acquired\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\t// the user has called release during acquired state\n\t\t\t\t\tlog.info( \"%s '%s' was closed by the user\",\n\t\t\t\t\t\ttype, name );\n\t\t\t\t\tthis.transition( \"releasing\" );\n\t\t\t\t},\n\t\t\t\treleased: function( reason ) {\n\t\t\t\t\t// the remote end initiated close\n\t\t\t\t\tlog.warn( \"%s '%s' was closed by the broker with reason '%s'\",\n\t\t\t\t\t\ttype, name, reason );\n\t\t\t\t\tthis.closeReason = reason;\n\t\t\t\t\tthis.transition( \"closed\" );\n\t\t\t\t},\n\t\t\t\tunblocked: function() {\n\t\t\t\t\tthis.transition( \"acquired\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tclosed: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tif( this.retry ) {\n\t\t\t\t\t\tclearTimeout( this.retry );\n\t\t\t\t\t}\n\t\t\t\t\tthis.emit( \"closed\", this.closeReason );\n\t\t\t\t\tthis.item = null;\n\t\t\t\t\tthis.closeReason = null;\n\t\t\t\t},\n\t\t\t\tacquire: function() {\n\t\t\t\t\tthis.transition( \"acquiring\" );\n\t\t\t\t},\n\t\t\t\toperate: function( call ) {\n\t\t\t\t\tlog.info( \"Operation '%s' invoked on closed %s '%s'\", call.operation, type, name );\n\t\t\t\t\tthis.deferUntilTransition( \"acquired\" );\n\t\t\t\t\tthis.transition( \"acquiring\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.transition( \"released\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\tthis.transition( \"released\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\tfailed: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis.retry = setTimeout( function() {\n\t\t\t\t\t\tif ( ( this.waitInterval + 100 ) < this.waitMax ) {\n\t\t\t\t\t\t\tthis.waitInterval += 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.transition( \"acquiring\" );\n\t\t\t\t\t}.bind( this ), this.waitInterval );\n\n\t\t\t\t},\n\t\t\t\tacquire: function() {\n\t\t\t\t\tif( this.retry ) {\n\t\t\t\t\t\tclearTimeout( this.retry );\n\t\t\t\t\t}\n\t\t\t\t\tthis.transition( \"acquiring\" );\n\t\t\t\t},\n\t\t\t\toperate: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"acquired\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.transition( \"released\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\t// this is expected because the close event fires after the error event on a channel or connection\n\t\t\t\t}\n\t\t\t},\n\t\t\treleasing: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis._release();\n\t\t\t\t},\n\t\t\t\tacquire: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"released\" );\n\t\t\t\t},\n\t\t\t\toperate: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"released\" );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.deferUntilTransition( \"released\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\tthis.transition( \"released\" );\n\t\t\t\t}\n\t\t\t},\n\t\t\treleased: {\n\t\t\t\t_onEnter: function() {\n\t\t\t\t\tthis._finalize();\n\t\t\t\t\tthis.emit( \"released\", this.id );\n\t\t\t\t},\n\t\t\t\tacquire: function() {\n\t\t\t\t\tthis.transition( \"acquiring\" );\n\t\t\t\t},\n\t\t\t\toperate: function( call ) {\n\t\t\t\t\tlog.warn( \"Operation '%s' invoked on released %s '%s' - reacquisition is required.\", call.operation, type, name );\n\t\t\t\t\tcall.reject( new Error( format( \"Cannot invoke operation '%s' on released %s '%s'\", call.operation, type, name ) ) );\n\t\t\t\t},\n\t\t\t\trelease: function() {\n\t\t\t\t\tthis.emit( \"released\" );\n\t\t\t\t},\n\t\t\t\treleased: function() {\n\t\t\t\t\tthis.emit( \"released\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n\tMonologue.mixInto( IOMonad );\n\tvar machine = new IOMonad();\n\t_.each( target.prototype, function( prop, name ) {\n\t\tif ( _.isFunction( prop ) ) {\n\t\t\tmachine[ name ] = function() {\n\t\t\t\tvar list = Array.prototype.slice.call( arguments, 0 );\n\t\t\t\treturn machine.operate( name, list );\n\t\t\t}.bind( machine );\n\t\t}\n\t} );\n\treturn machine;\n};\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/amqp/connection.js":"var amqp = require( \"amqplib\" );\nvar _ = require( \"lodash\" );\nvar fs = require( \"fs\" );\nvar when = require( \"when\" );\nvar AmqpConnection = require( \"amqplib/lib/callback_model\" ).CallbackModel;\nvar monad = require( \"./iomonad\" );\nvar log = require( \"../log\" )( \"rabbot.connection\" );\nvar info = require( \"../info\" );\nvar url = require( \"url\" );\n\n/* log\n\t* `rabbot.amqp-connection`\n\t  * `debug`\n\t    * when amqplib's `connection.close` promise is rejected\n\t * `info`\n\t    * connection attempt\n\t    * connection success\n\t    * connection failure\n\t    * no reachable endpoints\n*/\n\nfunction getArgs( fn ) {\n\tvar fnString = fn.toString();\n\treturn _.map( /[(]([^)]*)[)]/.exec( fnString )[ 1 ].split( ',' ), function( x ) {\n\t\treturn String.prototype.trim.bind( x )();\n\t} );\n}\n\nfunction getOption( opts, key, alt ) {\n\tif ( opts.get && supportsDefaults( opts.get ) ) {\n\t\treturn opts.get( key, alt );\n\t} else {\n\t\treturn opts[ key ] || alt;\n\t}\n}\n\nfunction getUri( protocol, user, pass, server, port, vhost, heartbeat ) {\n\treturn protocol + user + \":\" + pass +\n\t\t\"@\" + server + \":\" + port + \"/\" + vhost +\n\t\t\"?heartbeat=\" + heartbeat;\n}\n\nfunction parseUri( uri ) {\n\tif( uri ) {\n\t\tvar parsed = url.parse( uri );\n\t\tvar authSplit = parsed.auth ? parsed.auth.split( \":\" ) : [ null, null ];\n\t\tvar heartbeat = parsed.query ? parsed.query.split( \"&\" )[ 0 ].split( \"=\" )[ 1 ] : null;\n\t\treturn {\n\t\t\tuseSSL: parsed.protocol === \"amqps:\",\n\t\t\tuser: authSplit[ 0 ],\n\t\t\tpass: authSplit[ 1 ],\n\t\t\thost: parsed.hostname,\n\t\t\tport: parsed.port,\n\t\t\tvhost: parsed.pathname ? parsed.pathname.slice( 1 ) : undefined,\n\t\t\theartbeat: heartbeat\n\t\t};\n\t}\n}\n\nfunction split( x ) {\n\tif ( _.isNumber( x ) ) {\n\t\treturn [ x ];\n\t} else if ( _.isArray( x ) ) {\n\t\treturn x;\n\t} else {\n\t\treturn x.split( \",\" ).map( trim );\n\t}\n}\n\nfunction supportsDefaults( opts ) {\n\treturn opts.get && getArgs( opts.get ).length > 1;\n}\n\nfunction trim( x ) {\n\treturn x.trim( ' ' );\n}\n\nvar Adapter = function( parameters ) {\n\tvar uriOpts = parseUri( parameters.uri );\n\t_.merge( parameters, uriOpts );\n\tvar hosts = getOption( parameters, \"host\" );\n\tvar servers = getOption( parameters, \"server\" );\n\tvar brokers = getOption( parameters, \"RABBIT_BROKER\" );\n\tvar serverList = brokers || hosts || servers || \"localhost\";\n\tvar portList = getOption( parameters, \"RABBIT_PORT\" ) || getOption( parameters, \"port\", 5672 );\n\n\tthis.name = parameters ? ( parameters.name || \"default\" ) : \"default\";\n\tthis.connectionIndex = 0;\n\tthis.servers = split( serverList );\n\tthis.ports = split( portList );\n\tthis.heartbeat = getOption( parameters, \"RABBIT_HEARTBEAT\" ) || getOption( parameters, \"heartbeat\", 30 );\n\tthis.protocol = getOption( parameters, \"RABBIT_PROTOCOL\" ) || getOption( parameters, \"protocol\", \"amqp://\" );\n\tthis.pass = getOption( parameters, \"RABBIT_PASSWORD\" ) || getOption( parameters, \"pass\", \"guest\" );\n\tthis.user = getOption( parameters, \"RABBIT_USER\" ) || getOption( parameters, \"user\", \"guest\" );\n\tthis.vhost = getOption( parameters, \"RABBIT_VHOST\" ) || getOption( parameters, \"vhost\", \"%2f\" );\n\tvar timeout = getOption( parameters, \"RABBIT_TIMEOUT\" ) || getOption( parameters, \"timeout\", 2000 );\n\tvar certPath = getOption( parameters, \"RABBIT_CERT\" ) || getOption( parameters, \"certPath\" );\n\tvar keyPath = getOption( parameters, \"RABBIT_KEY\" ) || getOption( parameters, \"keyPath\" );\n\tvar caPaths = getOption( parameters, \"RABBIT_CA\" ) || getOption( parameters, \"caPath\" );\n\tvar passphrase = getOption( parameters, \"RABBIT_PASSPHRASE\" ) || getOption( parameters, \"passphrase\" );\n\tvar pfxPath = getOption( parameters, \"RABBIT_PFX\" ) || getOption( parameters, \"pfxPath\" );\n\tvar useSSL = certPath || keyPath || passphrase || caPaths || pfxPath;\n\tthis.options = { noDelay: true };\n\tif ( timeout ) {\n\t\tthis.options.timeout = timeout;\n\t}\n\tif ( certPath ) {\n\t\tthis.options.cert = fs.existsSync(certPath)? fs.readFileSync( certPath ) : certPath;\n\t}\n\tif ( keyPath ) {\n\t\tthis.options.key = fs.existsSync(keyPath)? fs.readFileSync( keyPath ) : keyPath;\n\t}\n\tif ( passphrase ) {\n\t\tthis.options.passphrase = passphrase;\n\t}\n\tif ( pfxPath ) {\n\t\tthis.options.pfx = fs.existsSync(pfxPath)? fs.readFileSync( pfxPath ) : pfxPath;\n\t}\n\tif ( caPaths ) {\n\t\tvar list = caPaths.split( ',' );\n\t\tthis.options.ca = _.map( list, function( caPath ) {\n\t\t\treturn fs.existsSync(caPath)? fs.readFileSync( caPath ) : caPath;\n\t\t} );\n\t}\n\tif ( useSSL ) {\n\t\tthis.protocol = 'amqps://';\n\t}\n\tthis.options.clientProperties = {\n\t\thost: info.host(),\n\t\tprocess: info.process(),\n\t\tlib: info.lib()\n\t};\n\tthis.limit = _.max( [ this.servers.length, this.ports.length ] );\n};\n\nAdapter.prototype.connect = function() {\n\treturn when.promise( function( resolve, reject ) {\n\t\tvar attempted = [];\n\t\tvar attempt;\n\t\tattempt = function() {\n\t\t\tvar nextUri = this.getNextUri();\n\t\t\tlog.info( \"Attempting connection to '%s' (%s)\", this.name, nextUri );\n\t\t\tfunction onConnection( connection ) {\n\t\t\t\tconnection.uri = nextUri;\n\t\t\t\tlog.info( \"Connected to '%s' (%s)\", this.name, nextUri );\n\t\t\t\tresolve( connection );\n\t\t\t}\n\t\t\tfunction onConnectionError( err ) {\n\t\t\t\tlog.info( \"Failed to connect to '%s' (%s) with, '%s'\", this.name, nextUri, err );\n\t\t\t\tattempted.push( nextUri );\n\t\t\t\tthis.bumpIndex();\n\t\t\t\tif( attempted.length < this.limit ) {\n\t\t\t\t\tattempt( err );\n\t\t\t\t} else {\n\t\t\t\t\tlog.info( \"Cannot connect to `%s` - all endpoints failed\", this.name );\n\t\t\t\t\treject( \"No endpoints could be reached\" );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( _.indexOf( attempted, nextUri ) < 0 ) {\n\t\t\t\tamqp.connect( nextUri, Object.assign( { servername: url.parse(nextUri).hostname }, this.options ))\n\t\t\t\t\t.then( onConnection.bind( this ), onConnectionError.bind( this ) );\n\t\t\t} else {\n\t\t\t\tlog.info( \"Cannot connect to `%s` - all endpoints failed\", this.name );\n\t\t\t\treject( \"No endpoints could be reached\" );\n\t\t\t}\n\t\t}.bind( this );\n\t\tattempt();\n\t}.bind( this ) );\n};\n\nAdapter.prototype.bumpIndex = function() {\n\tif ( this.limit - 1 > this.connectionIndex ) {\n\t\tthis.connectionIndex++;\n\t} else {\n\t\tthis.connectionIndex = 0;\n\t}\n};\n\nAdapter.prototype.getNextUri = function() {\n\tvar server = this.getNext( this.servers );\n\tvar port = this.getNext( this.ports );\n\tvar uri = getUri( this.protocol, this.user, escape( this.pass ), server, port, this.vhost, this.heartbeat );\n\treturn uri;\n};\n\nAdapter.prototype.getNext = function( list ) {\n\tif ( this.connectionIndex >= list.length ) {\n\t\treturn list[ 0 ];\n\t} else {\n\t\treturn list[ this.connectionIndex ];\n\t}\n};\n\nmodule.exports = function( options ) {\n\tvar close = function( connection ) {\n\t\tconnection.close()\n\t\t\t.then( null, function( err ) {\n\t\t\t\t// for some reason calling close always gets a rejected promise\n\t\t\t\t// I can't imagine a good reason for this, so I'm basically\n\t\t\t\t// only showing this at the debug level\n\t\t\t\tlog.debug( \"Error was reported during close of connection `%s` - `%s`\", options.name, err );\n\t\t\t} );\n\t};\n\tvar adapter = new Adapter( options );\n\treturn monad( options.name, \"connection\", adapter.connect.bind( adapter ), AmqpConnection, close );\n};\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/amqp/exchange.js":"var _ = require( \"lodash\" );\nvar when = require( \"when\" );\nvar info = require( \"../info\" );\nvar exLog = require( \"../log.js\" )( \"rabbot.exchange\" );\nvar topLog = require( \"../log.js\" )( \"rabbot.topology\" );\nvar format = require( \"util\" ).format;\n\n/* log\n\t* `rabbot.exchange`\n\t  * `debug`\n\t    * details for message publish - very verbose\n\t  * `info`\n\t  * `error`\n\t    * no serializer is defined for message's content type\n\t* `rabbot.topology`\n\t  * `info`\n\t    * exchange declaration\n*/\n\nfunction aliasOptions( options, aliases ) {\n\tvar aliased = _.transform( options, function( result, value, key ) {\n\t\tvar alias = aliases[ key ];\n\t\tresult[ alias || key ] = value;\n\t} );\n\treturn _.omit( aliased, Array.prototype.slice.call( arguments, 2 ) );\n}\n\nfunction define( channel, options, connectionName ) {\n\tvar valid = aliasOptions( options, {\n\t\talternate: \"alternateExchange\"\n\t}, \"limit\", \"persistent\", \"publishTimeout\" );\n\ttopLog.info( \"Declaring %s exchange '%s' on connection '%s' with the options: %s\",\n\t\toptions.type,\n\t\toptions.name,\n\t\tconnectionName,\n\t\tJSON.stringify( _.omit( valid, [ \"name\", \"type\" ] ) )\n\t);\n  if( options.name === \"\" ) {\n    return when( true );\n  } else if( options.passive ) {\n    return channel.checkExchange( options.name );\n  } else {\n    return channel.assertExchange( options.name, options.type, valid );\n  }\n}\n\nfunction getContentType( message ) {\n\tif( message.contentType ) {\n\t\treturn message.contentType;\n\t} else if( _.isString( message.body ) ) {\n\t\treturn \"text/plain\";\n\t} else if( _.isObject( message.body ) && !Buffer.isBuffer( message.body ) ) {\n\t\treturn \"application/json\";\n\t} else {\n\t\treturn \"application/octet-stream\";\n\t}\n}\n\nfunction publish( channel, options, topology, log, serializers, message ) {\n\tvar channelName = options.name;\n\tvar type = options.type;\n\tvar baseHeaders = {\n\t\t\"CorrelationId\": message.correlationId\n\t};\n\tmessage.headers = _.merge( baseHeaders, message.headers );\n\tvar contentType = getContentType( message );\n\tvar serializer = serializers[ contentType ];\n\tif( !serializer ) {\n\t\tvar errMessage = format( \"Failed to publish message with contentType '%s' - no serializer defined\", contentType );\n\t\texLog.error( errMessage );\n\t\treturn when.reject( new Error( errMessage ) );\n\t}\n\tvar payload = serializer.serialize( message.body );\n\tvar publishOptions = {\n\t\ttype: message.type || \"\",\n\t\tcontentType:contentType,\n\t\tcontentEncoding: \"utf8\",\n\t\tcorrelationId: message.correlationId || \"\",\n\t\treplyTo: message.replyTo || topology.replyQueue.name || \"\",\n\t\tmessageId: message.messageId || message.id || \"\",\n\t\ttimestamp: message.timestamp || Date.now(),\n\t\tappId: message.appId || info.id,\n\t\theaders: message.headers || {},\n\t\texpiration: message.expiresAfter || undefined,\n\t\tmandatory: message.mandatory || false\n\t};\n\tif ( publishOptions.replyTo === \"amq.rabbitmq.reply-to\" ) {\n\t\tpublishOptions.headers[ \"direct-reply-to\" ] = \"true\";\n\t}\n\tif ( !message.sequenceNo ) {\n\t\tlog.add( message );\n\t}\n\tif ( options.persistent || message.persistent ) {\n\t\tpublishOptions.persistent = true;\n\t}\n\n\tvar effectiveKey = message.routingKey === '' ? '' : message.routingKey || publishOptions.type;\n\texLog.debug( \"Publishing message ( type: '%s' topic: '%s', sequence: '%s', correlation: '%s', replyTo: '%s' ) to %s exchange '%s' on connection '%s'\",\n\t\tpublishOptions.type,\n\t\teffectiveKey,\n\t\tmessage.sequenceNo,\n\t\tpublishOptions.correlationId,\n\t\tJSON.stringify( publishOptions ),\n\t\ttype,\n\t\tchannelName,\n\t\ttopology.connection.name );\n\n\tfunction onRejected( err ) {\n\t\tlog.remove( message );\n\t\tthrow err;\n\t}\n\n\tfunction onConfirmed( sequence ) {\n\t\tlog.remove( message );\n\t\treturn sequence;\n\t}\n\n\tvar deferred = when.defer();\n\tvar promise = deferred.promise;\n\n\tchannel.publish(\n\t\tchannelName,\n\t\teffectiveKey,\n\t\tpayload,\n\t\tpublishOptions,\n\t\tfunction( err, i ) {\n\t\t\tif( err ) {\n\t\t\t\tdeferred.reject( err );\n\t\t\t} else {\n\t\t\t\tdeferred.resolve( i );\n\t\t\t}\n\t\t}\n\t);\n\n\treturn promise\n\t\t.then( onConfirmed, onRejected );\n}\n\nmodule.exports = function( options, topology, publishLog, serializers ) {\n\treturn topology.connection.getChannel( options.name, true, \"exchange channel for \" + options.name )\n\t\t.then( function( channel ) {\n\t\t\treturn {\n\t\t\t\tchannel: channel,\n\t\t\t\tdefine: define.bind( undefined, channel, options, topology.connection.name ),\n\t\t\t\trelease: function() {\n\t\t\t\t\tif ( channel ) {\n\t\t\t\t\t\tchannel.release();\n\t\t\t\t\t\tchannel = undefined;\n\t\t\t\t\t}\n\t\t\t\t\treturn when( true );\n\t\t\t\t},\n\t\t\t\tpublish: publish.bind( undefined, channel, options, topology, publishLog, serializers )\n\t\t\t};\n\t\t} );\n};\n","/home/travis/build/npmtest/node-npmtest-rabbot/node_modules/rabbot/src/amqp/queue.js":"var _ = require( \"lodash\" );\nvar AckBatch = require( \"../ackBatch.js\" );\nvar postal = require( \"postal\" );\nvar dispatch = postal.channel( \"rabbit.dispatch\" );\nvar responses = postal.channel( \"rabbit.responses\" );\nvar when = require( \"when\" );\nvar info = require( \"../info\" );\nvar log = require( \"../log\" )( \"rabbot.queue\" );\nvar format = require( \"util\" ).format;\nvar topLog = require( \"../log\" )( \"rabbot.topology\" );\nvar unhandledLog = require( \"../log\" )( \"rabbot.unhandled\" );\nvar noOp = function() {};\n\n/* log\n\t* `rabbot.amqp-queue`\n\t  * `debug`\n\t    * for all message operations - ack, nack, reply & reject\n\t  * `info`\n\t    * subscribing\n\t    * unsubscribing\n\t  * `warn`\n\t    * no message handlers for message received\n\t  * `error`\n\t    * no serializer defined for outgoing message\n\t    * no serializer defined for incoming message\n\t    * message nacked/rejected when consumer is set to no-ack\n\t* `rabbot.topology`\n\t  * `info`\n\t    * queue declaration\n*/\n\nfunction aliasOptions( options, aliases ) {\n\tvar aliased = _.transform( options, function( result, value, key ) {\n\t\tvar alias = aliases[ key ];\n\t\tresult[ alias || key ] = value;\n\t} );\n\treturn _.omit( aliased, Array.prototype.slice.call( arguments, 2 ) );\n}\n\nfunction define( channel, options, subscriber, connectionName ) {\n\tvar valid = aliasOptions( options, {\n\t\tqueuelimit: \"maxLength\",\n\t\tqueueLimit: \"maxLength\",\n\t\tdeadletter: \"deadLetterExchange\",\n\t\tdeadLetter: \"deadLetterExchange\",\n\t\tdeadLetterRoutingKey: \"deadLetterRoutingKey\"\n\t}, \"subscribe\", \"limit\", \"noBatch\", \"unique\" );\n\ttopLog.info( \"Declaring queue '%s' on connection '%s' with the options: %s\",\n\t\toptions.uniqueName, connectionName, JSON.stringify( _.omit( options, [ \"name\" ] ) ) );\n\treturn channel.assertQueue( options.uniqueName, valid )\n\t\t.then( function( q ) {\n\t\t\tif ( options.limit ) {\n\t\t\t\tchannel.prefetch( options.limit );\n\t\t\t}\n\t\t\treturn q;\n\t\t} );\n}\n\nfunction finalize( channel, messages ) {\n\tmessages.reset();\n\tmessages.ignoreSignal();\n\tchannel.release();\n\tchannel = undefined;\n}\n\nfunction getContentType( body, options ) {\n\tif( options && options.contentType ) {\n\t\treturn options.contentType;\n\t}\n\telse if( _.isString( body ) ) {\n\t\treturn \"text/plain\";\n\t} else if( _.isObject( body ) && !body.length ) {\n\t\treturn \"application/json\";\n\t} else {\n\t\treturn \"application/octet-stream\";\n\t}\n}\n\nfunction getCount( messages ) {\n\tif ( messages ) {\n\t\treturn messages.messages.length;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nfunction getNoBatchOps( channel, raw, messages, noAck ) {\n\tmessages.receivedCount += 1;\n\n\tvar ack, nack, reject;\n\tif ( noAck ) {\n\t\tack = noOp;\n\t\tnack = function() {\n\t\t\tlog.error( \"Tag %d on '%s' - '%s' cannot be nacked in noAck mode - message will be lost!\", raw.fields.deliveryTag, messages.name, messages.connectionName );\n\t\t};\n\t\treject = function() {\n\t\t\tlog.error( \"Tag %d on '%s' - '%s' cannot be rejected in noAck mode - message will be lost!\", raw.fields.deliveryTag, messages.name, messages.connectionName );\n\t\t};\n\t} else {\n\t\tack = function() {\n\t\t\tlog.debug( \"Acking tag %d on '%s' - '%s'\", raw.fields.deliveryTag, messages.name, messages.connectionName );\n\t\t\tchannel.ack( { fields: { deliveryTag: raw.fields.deliveryTag } }, false );\n\t\t};\n\t\tnack = function() {\n\t\t\tlog.debug( \"Nacking tag %d on '%s' - '%s'\", raw.fields.deliveryTag, messages.name, messages.connectionName );\n\t\t\tchannel.nack( { fields: { deliveryTag: raw.fields.deliveryTag } }, true );\n\t\t};\n\t\treject = function() {\n\t\t\tlog.debug( \"Rejecting tag %d on '%s' - '%s'\", raw.fields.deliveryTag, messages.name, messages.connectionName );\n\t\t\tchannel.reject( { fields: { deliveryTag: raw.fields.deliveryTag } }, false );\n\t\t};\n\t}\n\n\treturn {\n\t\tack: ack,\n\t\tnack: nack,\n\t\treject: reject\n\t};\n}\n\nfunction getReply( channel, serializers, raw, replyQueue, connectionName ) {\n\tvar position = 0;\n\treturn function( reply, options ) {\n\t\tvar defaultReplyType = raw.type + \".reply\";\n\t\tvar replyType = options ? ( options.replyType || defaultReplyType ) : defaultReplyType;\n\t\tvar contentType = getContentType( reply, options );\n\t\tvar serializer = serializers[ contentType ];\n\t\tif( !serializer ) {\n\t\t\tvar message = format( \"Failed to publish message with contentType %s - no serializer defined\", contentType );\n\t\t\tlog.error( message );\n\t\t\treturn when.reject( new Error( message ) );\n\t\t}\n\t\tvar payload = serializer.serialize( reply );\n\n\t\tvar replyTo = raw.properties.replyTo;\n\t\traw.ack();\n\t\tif ( replyTo ) {\n\t\t\tvar publishOptions = {\n\t\t\t\t\ttype: replyType,\n\t\t\t\t\tcontentType: contentType,\n\t\t\t\t\tcontentEncoding: \"utf8\",\n\t\t\t\t\tcorrelationId: raw.properties.messageId,\n\t\t\t\t\ttimestamp: options && options.timestamp ? options.timestamp : Date.now(),\n\t\t\t\t\treplyTo: replyQueue === false ? undefined : replyQueue,\n\t\t\t\t\theaders: options && options.headers ? options.headers : {}\n\t\t\t\t};\n\t\t\tif ( options && options.more ) {\n\t\t\t\tpublishOptions.headers.position = ( position++ );\n\t\t\t} else {\n\t\t\t\tpublishOptions.headers.sequence_end = true; // jshint ignore:line\n\t\t\t}\n\t\t\tlog.debug( \"Replying to message %s on '%s' - '%s' with type '%s'\",\n\t\t\t\traw.properties.messageId,\n\t\t\t\treplyTo,\n\t\t\t\tconnectionName,\n\t\t\t\tpublishOptions.type );\n\t\t\tif ( raw.properties.headers && raw.properties.headers[ \"direct-reply-to\" ] ) {\n\t\t\t\treturn channel.publish(\n\t\t\t\t\t'',\n\t\t\t\t\treplyTo,\n\t\t\t\t\tpayload,\n\t\t\t\t\tpublishOptions\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn channel.sendToQueue( replyTo, payload, publishOptions );\n\t\t\t}\n\t\t} else {\n\t\t\treturn when.reject( new Error( \"Cannot reply to a message that has no return address\" ) );\n\t\t}\n\t};\n}\n\nfunction getResolutionOperations( channel, raw, messages, options ) {\n\tif ( options.noBatch ) {\n\t\treturn getNoBatchOps( channel, raw, messages, options.noAck );\n\t}\n\n\tif ( options.noAck || options.noBatch ) {\n\t\treturn getUntrackedOps( channel, raw, messages );\n\t}\n\n\treturn getTrackedOps( raw, messages );\n}\n\nfunction getTrackedOps( raw, messages ) {\n\treturn messages.getMessageOps( raw.fields.deliveryTag );\n}\n\nfunction getUntrackedOps( channel, raw, messages ) {\n\tmessages.receivedCount += 1;\n\treturn {\n\t\tack: noOp,\n\t\tnack: function() {\n\t\t\tlog.error( \"Tag %d on '%s' - '%s' cannot be nacked in noAck mode - message will be lost!\", raw.fields.deliveryTag, messages.name, messages.connectionName );\n\t\t},\n\t\treject: function() {\n\t\t\tlog.error( \"Tag %d on '%s' - '%s' cannot be rejected in noAck mode - message will be lost!\", raw.fields.deliveryTag, messages.name, messages.connectionName );\n\t\t}\n\t};\n}\n\nfunction release( channel, options, messages, released ) {\n\tfunction onUnsubscribed() {\n\t\treturn when.promise( function( resolve ) {\n\t\t\tif ( messages.messages.length && !released ) {\n\t\t\t\tmessages.once( \"empty\", function() {\n\t\t\t\t\tfinalize( channel, messages );\n\t\t\t\t\tresolve();\n\t\t\t\t} );\n\t\t\t} else {\n        finalize( channel, messages );\n\t\t\t\tresolve();\n\t\t\t}\n\t\t}.bind( this ) );\n\t}\n\treturn unsubscribe( channel, options )\n\t\t.then( onUnsubscribed, onUnsubscribed );\n}\n\nfunction resolveTags( channel, queue, connection ) {\n\treturn function( op, data ) {\n\t\tswitch (op) {\n\t\t\tcase \"ack\":\n\t\t\t\tlog.debug( \"Acking tag %d on '%s' - '%s'\", data.tag, queue, connection );\n\t\t\t\treturn channel.ack( { fields: { deliveryTag: data.tag } }, data.inclusive );\n\t\t\tcase \"nack\":\n\t\t\t\tlog.debug( \"Nacking tag %d on '%s' - '%s'\", data.tag, queue, connection );\n\t\t\t\treturn channel.nack( { fields: { deliveryTag: data.tag } }, data.inclusive );\n\t\t\tcase \"reject\":\n\t\t\t\tlog.debug( \"Rejecting tag %d on '%s' - '%s'\", data.tag, queue, connection );\n\t\t\t\treturn channel.nack( { fields: { deliveryTag: data.tag } }, data.inclusive, false );\n\t\t\tdefault:\n\t\t\t\treturn when( true );\n\t\t}\n\t};\n}\n\nfunction subscribe( channelName, channel, topology, serializers, messages, options, exclusive ) {\n\tvar shouldAck = !options.noAck;\n\tvar shouldBatch = !options.noBatch;\n\tvar shouldCacheKeys = !options.noCacheKeys\n  // this is done to support rabbit-assigned queue names\n  channelName = channelName || options.name\n\tif ( shouldAck && shouldBatch ) {\n\t\tmessages.listenForSignal();\n\t}\n\n\toptions.consumerTag = info.createTag( channelName );\n\tif( _.keys( channel.item.consumers ).length > 0 ) {\n\t\tlog.info( \"Duplicate subscription to queue %s ignored\", channelName );\n\t\treturn when( options.consumerTag );\n\t}\n\tlog.info( \"Starting subscription to queue '%s' on '%s'\", channelName, topology.connection.name );\n  return channel.consume( channelName, function( raw ) {\n\t\tif( !raw ) {\n\t\t\t// this happens when the consumer has been cancelled\n\t\t\tlog.warn( \"Queue '%s' was sent a consumer cancel notification\" );\n\t\t\tthrow new Error( \"Broker cancelled the consumer remotely\" );\n\t\t}\n\t\tvar correlationId = raw.properties.correlationId;\n\t\tvar ops = getResolutionOperations( channel, raw, messages, options );\n\n\t\traw.ack = ops.ack;\n\t\traw.nack = ops.nack;\n\t\traw.reject = ops.reject;\n\t\traw.reply = getReply( channel, serializers, raw, topology.replyQueue.name, topology.connection.name );\n\t\traw.type = _.isEmpty( raw.properties.type ) ? raw.fields.routingKey : raw.properties.type;\n\t\tif( exclusive ) {\n\t\t\toptions.exclusive = true;\n\t\t}\n\t\traw.queue = channelName;\n\t\tvar parts = [ channelName.replace( /[.]/g, \"-\" ) ];\n\t\tif( raw.type ) {\n\t\t\tparts.push( raw.type );\n\t\t}\n\t\tvar topic = parts.join( \".\" );\n\t\tvar contentType = raw.properties.contentType || \"application/octet-stream\";\n\t\tvar serializer = serializers[ contentType ];\n\t\tif( !serializer ) {\n\t\t\tlog.error( \"Could not deserialize message id %s on queue '%s', connection '%s' - no serializer defined\",\n\t\t\t\traw.properties.messageId, channelName, topology.connection.name );\n\t\t\tops.nack();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\traw.body = serializer.deserialize( raw.content, raw.properties.contentEncoding );\n\t\t\t} catch( err ) {\n\t\t\t\tops.nack();\n\t\t\t}\n\t\t}\n\n\t\tvar onPublish = function( data ) {\n\t\t\tvar handled;\n\n\t\t\tif ( data.activated ) {\n\t\t\t\thandled = true;\n\t\t\t}\n\t\t\tif ( shouldAck && shouldBatch ) {\n\t\t\t\tmessages.addMessage( ops.message );\n\t\t\t}\n\n\t\t\tif ( !handled ) {\n\t\t\t\tunhandledLog.warn( \"Message of %s on queue '%s', connection '%s' was not processed by any registered handlers\",\n\t\t\t\t\traw.type,\n\t\t\t\t\tchannelName,\n\t\t\t\t\ttopology.connection.name\n\t\t\t\t);\n\t\t\t\ttopology.onUnhandled( raw );\n\t\t\t}\n\t\t};\n\n\t\tif ( raw.fields.routingKey === topology.replyQueue.name ) {\n\t\t\tresponses.publish(\n\t\t\t\t{\n\t\t\t\t\ttopic: correlationId,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\tresolverNoCache: true\n\t\t\t\t\t},\n\t\t\t\t\tdata: raw\n\t\t\t\t},\n\t\t\t\tonPublish\n\t\t\t);\n\t\t} else {\n\t\t\tdispatch.publish( {\n\t\t\t\ttopic: topic,\n\t\t\t\theaders: {\n\t\t\t\t\tresolverNoCache: !shouldCacheKeys\n\t\t\t\t},\n\t\t\t\tdata: raw\n\t\t\t}, onPublish );\n\t\t}\n\t}, options )\n\t\t.then( function( result ) {\n\t\t\tchannel.tag = result.consumerTag;\n\t\t\treturn result;\n\t\t}, function( err ) {\n      log.error( \"Error on channel consume\", options );\n      throw err;\n    } );\n}\n\nfunction unsubscribe( channel, options ) {\n\tif ( channel.tag ) {\n\t\tlog.info( \"Unsubscribing from queue '%s' with tag %s\", options.name, channel.tag );\n\t\treturn channel.cancel( channel.tag );\n\t} else {\n\t\treturn when.resolve();\n\t}\n}\n\nmodule.exports = function( options, topology, serializers ) {\n  var channelName = [ \"queue\", options.uniqueName ].join( \":\" );\n\treturn topology.connection.getChannel( channelName, false, \"queue channel for \" + options.name )\n\t\t.then( function( channel ) {\n\t\t\tvar messages = new AckBatch( options.name, topology.connection.name, resolveTags( channel, options.name, topology.connection.name ) );\n\t\t\tvar subscriber = subscribe.bind( undefined, options.uniqueName, channel, topology, serializers, messages, options );\n\n\t\t\treturn {\n\t\t\t\tchannel: channel,\n\t\t\t\tmessages: messages,\n\t\t\t\tdefine: define.bind( undefined, channel, options, subscriber, topology.connection.name ),\n\t\t\t\tfinalize: finalize.bind( undefined, channel, messages ),\n\t\t\t\tgetMessageCount: getCount.bind( undefined, messages ),\n\t\t\t\trelease: release.bind( undefined, channel, options, messages ),\n\t\t\t\tsubscribe: subscriber,\n\t\t\t\tunsubscribe: unsubscribe.bind( undefined, channel, options, messages )\n\t\t\t};\n\t\t} );\n};\n"}